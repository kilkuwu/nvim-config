{
  "cf": {
    "prefix": "cf",
    "body": [
      "#include <bits/stdc++.h>",
      "",
      "#define nl '\\n'",
      "",
      "#ifdef LOCAL",
      "#include \"template/debug.hpp\"",
      "#else",
      "#define dbg(...) ;",
      "#define timer(...) ;",
      "#endif",
      "",
      "void antisocial() {",
      "  $0",
      "}",
      "",
      "signed main() {",
      "  std::ios::sync_with_stdio(false);",
      "  std::cin.tie(nullptr);",
      "  int t = 1;",
      "  std::cin >> t;",
      "  while (t--)",
      "    antisocial();",
      "}"
    ],
    "description": "cf"
  },
  "cp": {
    "prefix": "cp",
    "body": [
      "#include <bits/stdc++.h>",
      "",
      "#define nl '\\n'",
      "",
      "#ifdef LOCAL",
      "#include \"template/debug.hpp\"",
      "#else",
      "#define dbg(...) ;",
      "#define timer(...) ;",
      "#endif",
      "",
      "signed main() {",
      "  std::ios::sync_with_stdio(false);",
      "  std::cin.tie(nullptr);",
      "  $0",
      "}"
    ],
    "description": "cp"
  },
  "dbgnc": {
    "prefix": "dbgnc",
    "body": [
      "#pragma once",
      "",
      "#include <algorithm>",
      "#include <chrono>",
      "#include <iostream>",
      "#include <queue>",
      "#include <stack>",
      "#include <vector>",
      "",
      "namespace __dbg {",
      "",
      "void print(char x) {",
      "  std::cerr << '\\'' << x << '\\'';",
      "}",
      "void print(const char* x) {",
      "  std::cerr << '\\\"' << x << '\\\"';",
      "}",
      "void print(const std::string& x) {",
      "  std::cerr << '\\\"' << x << '\\\"';",
      "}",
      "void print(bool x) {",
      "  std::cerr << (x ? \"true\" : \"false\");",
      "}",
      "",
      "namespace trait {",
      "using std::begin;",
      "using std::declval;",
      "using std::end;",
      "",
      "template <typename T>",
      "decltype(begin(declval<T&>()) != end(declval<T&>()), void(),",
      "         ++declval<decltype(begin(declval<T&>()))&>(), *begin(declval<T&>()),",
      "         std::true_type{})",
      "is_iterable_impl(int) {",
      "  return {};",
      "}",
      "",
      "template <typename T>",
      "std::false_type is_iterable_impl(...) {",
      "  return {};",
      "};",
      "",
      "template <typename T>",
      "using is_iterable = decltype(is_iterable_impl<T>(0));",
      "",
      "template <typename T>",
      "decltype(std::cerr << declval<T&>(), void(), std::true_type{})",
      "is_printable_impl(int) {",
      "  return {};",
      "}",
      "",
      "template <typename T>",
      "std::false_type is_printable_impl(...) {",
      "  return {};",
      "}",
      "",
      "template <typename T>",
      "using is_printable = decltype(is_printable_impl<T>(0));",
      "",
      "static_assert(!is_iterable<int>::value);",
      "}  // namespace trait",
      "",
      "template <typename T, typename U>",
      "void print(std::queue<T, U> q);",
      "",
      "template <typename T, typename U, typename V>",
      "void print(std::priority_queue<T, U, V> q);",
      "",
      "template <typename T, typename U>",
      "void print(std::stack<T, U> q);",
      "",
      "template <typename T, typename V>",
      "void print(const std::pair<T, V>&);",
      "",
      "template <typename... Args>",
      "void print(const std::tuple<Args...>& t);",
      "",
      "template <typename T>",
      "typename std::enable_if<trait::is_iterable<T>::value>::type print(const T& x);",
      "",
      "template <typename T>",
      "typename std::enable_if<trait::is_printable<T>::value &&",
      "                        !trait::is_iterable<T>::value>::type",
      "print(const T& x);",
      "",
      "/**",
      " * Implementation starts here",
      " */",
      "",
      "template <typename T, typename U>",
      "void print(std::queue<T, U> q) {",
      "  std::cerr << \"{\";",
      "  int f = 0;",
      "  while (q.size()) {",
      "    std::cerr << (f++ ? \", \" : \"\"), print(q.front());",
      "    q.pop();",
      "  }",
      "  std::cerr << \"}\";",
      "}",
      "",
      "template <typename T, typename U, typename V>",
      "void print(std::priority_queue<T, U, V> q) {",
      "  std::cerr << \"{\";",
      "  int f = 0;",
      "  while (q.size()) {",
      "    std::cerr << (f++ ? \", \" : \"\"), print(q.top());",
      "    q.pop();",
      "  }",
      "  std::cerr << \"}\";",
      "}",
      "",
      "template <typename T, typename U>",
      "void print(std::stack<T, U> q) {",
      "  std::vector<T> s;",
      "  while (q.size()) {",
      "    s.push_back(q.top());",
      "    q.pop();",
      "  }",
      "  std::reverse(s.begin(), s.end());",
      "  print(s);",
      "}",
      "",
      "template <typename T, typename V>",
      "void print(const std::pair<T, V>& x) {",
      "  std::cerr << '(';",
      "  print(x.first);",
      "  std::cerr << \", \";",
      "  print(x.second);",
      "  std::cerr << ')';",
      "}",
      "",
      "template <typename T, std::size_t N>",
      "struct TuplePrinter {",
      "  static void tuple_print(const T& t) {",
      "    TuplePrinter<T, N - 1>::tuple_print(t);",
      "    std::cerr << \", \";",
      "    print(std::get<N - 1>(t));",
      "  }",
      "};",
      "",
      "template <typename T>",
      "struct TuplePrinter<T, 1> {",
      "  static void tuple_print(const T& t) {",
      "    print(std::get<0>(t));",
      "  }",
      "};",
      "",
      "template <typename T>",
      "struct TuplePrinter<T, 0> {",
      "  static void tuple_print(const T&) {}",
      "};",
      "",
      "template <typename... Args>",
      "void print(const std::tuple<Args...>& t) {",
      "  std::cerr << \"(\";",
      "  TuplePrinter<decltype(t), sizeof...(Args)>::tuple_print(t);",
      "  std::cerr << \")\";",
      "}",
      "",
      "template <typename T>",
      "typename std::enable_if<trait::is_iterable<T>::value>::type print(const T& x) {",
      "  int f = 0;",
      "  std::cerr << '{';",
      "  for (const auto& i : x) std::cerr << (f++ ? \", \" : \"\"), print(i);",
      "  std::cerr << \"}\";",
      "}",
      "",
      "template <typename T>",
      "typename std::enable_if<trait::is_printable<T>::value &&",
      "                        !trait::is_iterable<T>::value>::type",
      "print(const T& x) {",
      "  std::cerr << x;",
      "}",
      "",
      "void print_many() {",
      "  std::cerr << \"]\\n\";",
      "}",
      "",
      "template <typename T, typename... V>",
      "void print_many(const std::initializer_list<T>& t, V... v) {",
      "  print(t);",
      "  if (sizeof...(v)) std::cerr << \", \";",
      "  print_many(v...);",
      "}",
      "",
      "template <typename T, typename... V>",
      "void print_many(T t, V... v) {",
      "  print(t);",
      "  if (sizeof...(v)) std::cerr << \", \";",
      "  print_many(v...);",
      "}",
      "",
      "struct Timer {",
      "  std::chrono::high_resolution_clock::time_point st, en;",
      "  std::string name;",
      "  std::string func;",
      "  int line;",
      "",
      "  Timer(std::string _name, std::string _func, int _line)",
      "      : name(_name), func(_func), line(_line) {",
      "    st = std::chrono::high_resolution_clock::now();",
      "  }",
      "",
      "  ~Timer() {",
      "    en = std::chrono::high_resolution_clock::now();",
      "    auto duration =",
      "        std::chrono::duration_cast<std::chrono::milliseconds>(en - st);",
      "    std::cerr << func << \":\" << line << \" \\\"\" << name << \"\\\": \";",
      "    std::cerr << duration.count() << \"ms\\n\" << std::endl;",
      "  }",
      "};",
      "",
      "void debug_prefix(std::string name, std::string func, int line) {",
      "  std::cerr << func << \":\" << line << \" [\" << name << \"] = [\";",
      "}",
      "",
      "void debug_suffix() {",
      "  std::cerr << std::endl;",
      "}",
      "}  // namespace __dbg",
      "",
      "#define dbg(x...)                                                    \\",
      "  __dbg::debug_prefix(#x, __func__, __LINE__), __dbg::print_many(x), \\",
      "      __dbg::debug_suffix();",
      "",
      "#define timer(name) __dbg::Timer name(#name, __func__, __LINE__);",
      ""
    ],
    "description": "dbgnc"
  },
  "debug": {
    "prefix": "debug",
    "body": [
      "#pragma once",
      "",
      "#include <algorithm>",
      "#include <chrono>",
      "#include <iostream>",
      "#include <queue>",
      "#include <stack>",
      "#include <vector>",
      "",
      "namespace __dbg {",
      "",
      "void print(char x) {",
      "  std::cerr << '\\'' << x << '\\'';",
      "}",
      "void print(const char* x) {",
      "  std::cerr << '\\\"' << x << '\\\"';",
      "}",
      "void print(const std::string& x) {",
      "  std::cerr << '\\\"' << x << '\\\"';",
      "}",
      "void print(bool x) {",
      "  std::cerr << (x ? \"true\" : \"false\");",
      "}",
      "",
      "namespace trait {",
      "using std::begin;",
      "using std::declval;",
      "using std::end;",
      "",
      "template <typename T>",
      "decltype(begin(declval<T&>()) != end(declval<T&>()), void(),",
      "         ++declval<decltype(begin(declval<T&>()))&>(), *begin(declval<T&>()),",
      "         std::true_type{})",
      "is_iterable_impl(int) {",
      "  return {};",
      "}",
      "",
      "template <typename T>",
      "std::false_type is_iterable_impl(...) {",
      "  return {};",
      "};",
      "",
      "template <typename T>",
      "using is_iterable = decltype(is_iterable_impl<T>(0));",
      "",
      "template <typename T>",
      "decltype(std::cerr << declval<T&>(), void(), std::true_type{})",
      "is_printable_impl(int) {",
      "  return {};",
      "}",
      "",
      "template <typename T>",
      "std::false_type is_printable_impl(...) {",
      "  return {};",
      "}",
      "",
      "template <typename T>",
      "using is_printable = decltype(is_printable_impl<T>(0));",
      "",
      "static_assert(!is_iterable<int>::value);",
      "}  // namespace trait",
      "",
      "template <typename T, typename U>",
      "void print(std::queue<T, U> q);",
      "",
      "template <typename T, typename U, typename V>",
      "void print(std::priority_queue<T, U, V> q);",
      "",
      "template <typename T, typename U>",
      "void print(std::stack<T, U> q);",
      "",
      "template <typename T, typename V>",
      "void print(const std::pair<T, V>&);",
      "",
      "template <typename... Args>",
      "void print(const std::tuple<Args...>& t);",
      "",
      "template <typename T>",
      "typename std::enable_if<trait::is_iterable<T>::value>::type print(const T& x);",
      "",
      "template <typename T>",
      "typename std::enable_if<trait::is_printable<T>::value &&",
      "                        !trait::is_iterable<T>::value>::type",
      "print(const T& x);",
      "",
      "/**",
      " * Implementation starts here",
      " */",
      "",
      "template <typename T, typename U>",
      "void print(std::queue<T, U> q) {",
      "  std::cerr << \"{\";",
      "  int f = 0;",
      "  while (q.size()) {",
      "    std::cerr << (f++ ? \", \" : \"\"), print(q.front());",
      "    q.pop();",
      "  }",
      "  std::cerr << \"}\";",
      "}",
      "",
      "template <typename T, typename U, typename V>",
      "void print(std::priority_queue<T, U, V> q) {",
      "  std::cerr << \"{\";",
      "  int f = 0;",
      "  while (q.size()) {",
      "    std::cerr << (f++ ? \", \" : \"\"), print(q.top());",
      "    q.pop();",
      "  }",
      "  std::cerr << \"}\";",
      "}",
      "",
      "template <typename T, typename U>",
      "void print(std::stack<T, U> q) {",
      "  std::vector<T> s;",
      "  while (q.size()) {",
      "    s.push_back(q.top());",
      "    q.pop();",
      "  }",
      "  std::reverse(s.begin(), s.end());",
      "  print(s);",
      "}",
      "",
      "template <typename T, typename V>",
      "void print(const std::pair<T, V>& x) {",
      "  std::cerr << '(';",
      "  print(x.first);",
      "  std::cerr << \", \";",
      "  print(x.second);",
      "  std::cerr << ')';",
      "}",
      "",
      "template <typename T, std::size_t N>",
      "struct TuplePrinter {",
      "  static void tuple_print(const T& t) {",
      "    TuplePrinter<T, N - 1>::tuple_print(t);",
      "    std::cerr << \", \";",
      "    print(std::get<N - 1>(t));",
      "  }",
      "};",
      "",
      "template <typename T>",
      "struct TuplePrinter<T, 1> {",
      "  static void tuple_print(const T& t) {",
      "    print(std::get<0>(t));",
      "  }",
      "};",
      "",
      "template <typename T>",
      "struct TuplePrinter<T, 0> {",
      "  static void tuple_print(const T&) {}",
      "};",
      "",
      "template <typename... Args>",
      "void print(const std::tuple<Args...>& t) {",
      "  std::cerr << \"(\";",
      "  TuplePrinter<decltype(t), sizeof...(Args)>::tuple_print(t);",
      "  std::cerr << \")\";",
      "}",
      "",
      "template <typename T>",
      "typename std::enable_if<trait::is_iterable<T>::value>::type print(const T& x) {",
      "  int f = 0;",
      "  std::cerr << '{';",
      "  for (const auto& i : x) std::cerr << (f++ ? \", \" : \"\"), print(i);",
      "  std::cerr << \"}\";",
      "}",
      "",
      "template <typename T>",
      "typename std::enable_if<trait::is_printable<T>::value &&",
      "                        !trait::is_iterable<T>::value>::type",
      "print(const T& x) {",
      "  std::cerr << x;",
      "}",
      "",
      "void print_many() {",
      "  std::cerr << \"]\\n\";",
      "}",
      "",
      "template <typename T, typename... V>",
      "void print_many(const std::initializer_list<T>& t, V... v) {",
      "  print(t);",
      "  if (sizeof...(v)) std::cerr << \", \";",
      "  print_many(v...);",
      "}",
      "",
      "template <typename T, typename... V>",
      "void print_many(T t, V... v) {",
      "  print(t);",
      "  if (sizeof...(v)) std::cerr << \", \";",
      "  print_many(v...);",
      "}",
      "",
      "namespace ANSI {",
      "const std::string reset_fg = \"\\033[0m\";",
      "const std::string pink = \"\\033[38;2;255;255;0m\";",
      "const std::string blue = \"\\033[38;2;0;255;0m\";",
      "};  // namespace ANSI",
      "",
      "struct Timer {",
      "  std::chrono::high_resolution_clock::time_point st, en;",
      "  std::string name;",
      "  std::string func;",
      "  int line;",
      "",
      "  Timer(std::string _name, std::string _func, int _line)",
      "      : name(_name), func(_func), line(_line) {",
      "    st = std::chrono::high_resolution_clock::now();",
      "  }",
      "",
      "  ~Timer() {",
      "    en = std::chrono::high_resolution_clock::now();",
      "    auto duration =",
      "        std::chrono::duration_cast<std::chrono::milliseconds>(en - st);",
      "    std::cerr << \"\\n\" << ANSI::pink;",
      "    std::cerr << func << \":\" << line << \" \\\"\" << name << \"\\\": \";",
      "    std::cerr << duration.count() << \"ms\\n\" << ANSI::reset_fg << std::endl;",
      "  }",
      "};",
      "",
      "void debug_prefix(std::string name, std::string func, int line) {",
      "  std::cerr << ANSI::blue;",
      "  std::cerr << func << \":\" << line << \" [\" << name << \"] = [\";",
      "}",
      "",
      "void debug_suffix() {",
      "  std::cerr << ANSI::reset_fg << std::endl;",
      "}",
      "}  // namespace __dbg",
      "",
      "#define dbg(...)                                                    \\",
      "  __dbg::debug_prefix(#__VA_ARGS__, __func__, __LINE__), __dbg::print_many(__VA_ARGS__), \\",
      "      __dbg::debug_suffix();",
      "",
      "#define timer(name) __dbg::Timer name(#name, __func__, __LINE__);",
      ""
    ],
    "description": "debug"
  },
  "fio": {
    "prefix": "fio",
    "body": [
      "#define TASK \"$0\"",
      "  if (fopen(TASK \".inp\", \"r\")) {",
      "    freopen(TASK \".inp\", \"r\", stdin);",
      "    freopen(TASK \".out\", \"w\", stdout);",
      "  }"
    ],
    "description": "fio"
  },
  "testing": {
    "prefix": "testing",
    "body": [
      "#include <bits/stdc++.h>",
      "",
      "#define nl '\\n'",
      "",
      "#ifdef LOCAL",
      "#include \"template/debug.hpp\"",
      "#else",
      "#define dbg(...) ;",
      "#define timer(...) ;",
      "#endif",
      "",
      "// std::mt19937_64 rng(0);",
      "std::mt19937_64 rng(std::chrono::high_resolution_clock::now().time_since_epoch().count());",
      "#define uid(a, b) std::uniform_int_distribution<long long>(a, b)(rng)",
      "",
      "// file name",
      "#define TASK \"B\"",
      "",
      "void build_test_1() {",
      "  std::ofstream inp(\"inp\");",
      "  // gen test here",
      "  inp.close();",
      "}",
      "",
      "signed main() {",
      "  int ntest = 10000;",
      "  for (int test = 1; test <= ntest; test++) {",
      "    std::cerr << \"TEST \" << test << std::endl;",
      "",
      "    build_test_1();",
      "",
      "    system(TASK \".exe < inp > wa\");",
      "    system(TASK \"_brute.exe < inp > ac\");",
      "",
      "    if (system(\"fc ac wa\") != 0) {",
      "      system(\"type inp\");",
      "      return 0;",
      "    }",
      "  }",
      "}"
    ],
    "description": "testing"
  },
  "matmul": {
    "prefix": "matmul",
    "body": [
      "",
      "constexpr int SZ = 256, __mat_md = 1e9 + 9;",
      "constexpr uint64_t threshold = (uint64_t) 16 * __mat_md * __mat_md;",
      "uint64_t __matmul_mat[SZ][SZ];",
      "int __matpow_mat[SZ][SZ];",
      "",
      "void matmul(int a[SZ][SZ], int b[SZ][SZ], int c[SZ][SZ]) {",
      "  for (int k = 0; k < SZ; k++) {",
      "    for (int i = 0; i < SZ; i++) {",
      "      for (int j = 0; j < SZ; j++) {",
      "        __matmul_mat[i][j] += (uint64_t) a[i][k] * b[k][j];",
      "        if (__matmul_mat[i][j] >= threshold) {",
      "          __matmul_mat[i][j] %= __mat_md;",
      "        }",
      "      }",
      "    }",
      "  }",
      "",
      "  for (int i = 0; i < SZ; i++) {",
      "    for (int j = 0; j < SZ; j++) {",
      "      c[i][j] = __matmul_mat[i][j] % __mat_md;",
      "      __matmul_mat[i][j] = 0;",
      "    }",
      "  }",
      "}",
      "",
      "void matpow(int b[SZ][SZ], int64_t e) {",
      "  memset(__matpow_mat, 0, sizeof(__matpow_mat));",
      "  for (int i = 0; i < SZ; i++) __matpow_mat[i][i] = 1;",
      "  while (e) {",
      "    if (e & 1) matmul(__matpow_mat, b, __matpow_mat);",
      "    matmul(b, b, b);",
      "    e >>= 1;",
      "  }",
      "  memcpy(b, __matpow_mat, sizeof(__matpow_mat));",
      "}",
      "",
      "int a[SZ][SZ];"
    ],
    "description": "matmul"
  },
  "bigint": {
    "prefix": "bigint",
    "body": [
      "namespace BigInteger {",
      "using cpx = std::complex<double>;",
      "const double PI = acos(-1);",
      "std::vector<cpx> roots = {{0, 0}, {1, 0}};",
      "",
      "void ensure_capacity(int min_capacity) {",
      "  for (int len = roots.size(); len < min_capacity; len *= 2) {",
      "    for (int i = len >> 1; i < len; i++) {",
      "      roots.emplace_back(roots[i]);",
      "      double angle = 2 * PI * (2 * i + 1 - len) / (len * 2);",
      "      roots.emplace_back(cos(angle), sin(angle));",
      "    }",
      "  }",
      "}",
      "",
      "void fft(std::vector<cpx> &z, bool inverse) {",
      "  int n = z.size();",
      "  assert((n & (n - 1)) == 0);",
      "  ensure_capacity(n);",
      "  for (unsigned i = 1, j = 0; i < (unsigned) n; i++) {",
      "    int bit = n >> 1;",
      "    for (; j >= (unsigned) bit; bit >>= 1) j -= bit;",
      "    j += bit;",
      "    if (i < j) swap(z[i], z[j]);",
      "  }",
      "  for (int len = 1; len < n; len <<= 1) {",
      "    for (int i = 0; i < n; i += len * 2) {",
      "      for (int j = 0; j < len; j++) {",
      "        cpx root = inverse ? conj(roots[j + len]) : roots[j + len];",
      "        cpx u = z[i + j];",
      "        cpx v = z[i + j + len] * root;",
      "        z[i + j] = u + v;",
      "        z[i + j + len] = u - v;",
      "      }",
      "    }",
      "  }",
      "  if (inverse)",
      "    for (int i = 0; i < n; i++) z[i] /= n;",
      "}",
      "",
      "std::vector<int> multiply_bigint(const std::vector<int> &a, const std::vector<int> &b, int base) {",
      "  int need = a.size() + b.size();",
      "  int n = 1;",
      "  while (n < need) n <<= 1;",
      "  std::vector<cpx> p(n);",
      "  for (size_t i = 0; i < (size_t) n; i++) {",
      "    p[i] = cpx(i < a.size() ? a[i] : 0, i < b.size() ? b[i] : 0);",
      "  }",
      "  fft(p, false);",
      "  // a[w[k]] = (p[w[k]] + conj(p[w[n-k]])) / 2",
      "  // b[w[k]] = (p[w[k]] - conj(p[w[n-k]])) / (2*i)",
      "  std::vector<cpx> ab(n);",
      "  cpx r(0, -0.25);",
      "  for (int i = 0; i < n; i++) {",
      "    int j = (n - i) & (n - 1);",
      "    ab[i] = (p[i] * p[i] - conj(p[j] * p[j])) * r;",
      "  }",
      "  fft(ab, true);",
      "  std::vector<int> result(need);",
      "  long long carry = 0;",
      "  for (int i = 0; i < need; i++) {",
      "    long long d = (long long) (ab[i].real() + 0.5) + carry;",
      "    carry = d / base;",
      "    result[i] = d % base;",
      "  }",
      "  return result;",
      "}",
      "",
      "std::vector<int> multiply_mod(const std::vector<int> &a, const std::vector<int> &b, int m) {",
      "  int need = a.size() + b.size() - 1;",
      "  int n = 1;",
      "  while (n < need) n <<= 1;",
      "  std::vector<cpx> A(n);",
      "  for (size_t i = 0; i < a.size(); i++) {",
      "    int x = (a[i] % m + m) % m;",
      "    A[i] = cpx(x & ((1 << 15) - 1), x >> 15);",
      "  }",
      "  fft(A, false);",
      "",
      "  std::vector<cpx> B(n);",
      "  for (size_t i = 0; i < b.size(); i++) {",
      "    int x = (b[i] % m + m) % m;",
      "    B[i] = cpx(x & ((1 << 15) - 1), x >> 15);",
      "  }",
      "  fft(B, false);",
      "",
      "  std::vector<cpx> fa(n);",
      "  std::vector<cpx> fb(n);",
      "  for (int i = 0, j = 0; i < n; i++, j = n - i) {",
      "    cpx a1 = (A[i] + conj(A[j])) * cpx(0.5, 0);",
      "    cpx a2 = (A[i] - conj(A[j])) * cpx(0, -0.5);",
      "    cpx b1 = (B[i] + conj(B[j])) * cpx(0.5, 0);",
      "    cpx b2 = (B[i] - conj(B[j])) * cpx(0, -0.5);",
      "    fa[i] = a1 * b1 + a2 * b2 * cpx(0, 1);",
      "    fb[i] = a1 * b2 + a2 * b1;",
      "  }",
      "",
      "  fft(fa, true);",
      "  fft(fb, true);",
      "  std::vector<int> res(need);",
      "  for (int i = 0; i < need; i++) {",
      "    long long aa = (long long) (fa[i].real() + 0.5);",
      "    long long bb = (long long) (fb[i].real() + 0.5);",
      "    long long cc = (long long) (fa[i].imag() + 0.5);",
      "    res[i] = (aa % m + (bb % m << 15) + (cc % m << 30)) % m;",
      "  }",
      "  return res;",
      "}",
      "",
      "constexpr int digits(int base) noexcept { return base <= 1 ? 0 : 1 + digits(base / 10); }",
      "",
      "constexpr int base = 1000'000'000;",
      "constexpr int base_digits = digits(base);",
      "",
      "constexpr int fft_base = 10'000;  // fft_base^2 * n / fft_base_digits <= 10^15 for double",
      "constexpr int fft_base_digits = digits(fft_base);",
      "",
      "struct BigInt {",
      "  // value == 0 is represented by empty z",
      "  std::vector<int> z;  // digits",
      "",
      "  // sign == 1 <==> value >= 0",
      "  // sign == -1 <==> value < 0",
      "  int sign;",
      "",
      "  BigInt(long long v = 0) { *this = v; }",
      "",
      "  BigInt &operator=(long long v) {",
      "    sign = v < 0 ? -1 : 1;",
      "    v *= sign;",
      "    z.clear();",
      "    for (; v > 0; v = v / base) z.push_back((int) (v % base));",
      "    return *this;",
      "  }",
      "",
      "  BigInt(const std::string &s) { read(s); }",
      "",
      "  BigInt &operator+=(const BigInt &other) {",
      "    if (sign == other.sign) {",
      "      for (int i = 0, carry = 0; i < (int) other.z.size() || carry; ++i) {",
      "        if (i == (int) z.size()) z.push_back(0);",
      "        z[i] += carry + (i < (int) other.z.size() ? other.z[i] : 0);",
      "        carry = z[i] >= base;",
      "        if (carry) z[i] -= base;",
      "      }",
      "    } else if (other != 0 /* prevent infinite loop */) {",
      "      *this -= -other;",
      "    }",
      "    return *this;",
      "  }",
      "",
      "  friend BigInt operator+(BigInt a, const BigInt &b) {",
      "    a += b;",
      "    return a;",
      "  }",
      "",
      "  BigInt &operator-=(const BigInt &other) {",
      "    if (sign == other.sign) {",
      "      if ((sign == 1 && *this >= other) || (sign == -1 && *this <= other)) {",
      "        for (int i = 0, carry = 0; i < (int) other.z.size() || carry; ++i) {",
      "          z[i] -= carry + (i < (int) other.z.size() ? other.z[i] : 0);",
      "          carry = z[i] < 0;",
      "          if (carry) z[i] += base;",
      "        }",
      "        trim();",
      "      } else {",
      "        *this = other - *this;",
      "        this->sign = -this->sign;",
      "      }",
      "    } else {",
      "      *this += -other;",
      "    }",
      "    return *this;",
      "  }",
      "",
      "  friend BigInt operator-(BigInt a, const BigInt &b) {",
      "    a -= b;",
      "    return a;",
      "  }",
      "",
      "  BigInt &operator*=(int v) {",
      "    if (v < 0) sign = -sign, v = -v;",
      "    for (int i = 0, carry = 0; i < (int) z.size() || carry; ++i) {",
      "      if (i == (int) z.size()) z.push_back(0);",
      "      long long cur = (long long) z[i] * v + carry;",
      "      carry = (int) (cur / base);",
      "      z[i] = (int) (cur % base);",
      "    }",
      "    trim();",
      "    return *this;",
      "  }",
      "",
      "  BigInt operator*(int v) const { return BigInt(*this) *= v; }",
      "",
      "  friend std::pair<BigInt, BigInt> divmod(const BigInt &a1, const BigInt &b1) {",
      "    int norm = base / (b1.z.back() + 1);",
      "    BigInt a = a1.abs() * norm;",
      "    BigInt b = b1.abs() * norm;",
      "    BigInt q, r;",
      "    q.z.resize(a.z.size());",
      "",
      "    for (int i = (int) a.z.size() - 1; i >= 0; i--) {",
      "      r *= base;",
      "      r += a.z[i];",
      "      int s1 = b.z.size() < r.z.size() ? r.z[b.z.size()] : 0;",
      "      int s2 = b.z.size() - 1 < r.z.size() ? r.z[b.z.size() - 1] : 0;",
      "      int d = (int) (((long long) s1 * base + s2) / b.z.back());",
      "      r -= b * d;",
      "      while (r < 0) r += b, --d;",
      "      q.z[i] = d;",
      "    }",
      "",
      "    q.sign = a1.sign * b1.sign;",
      "    r.sign = a1.sign;",
      "    q.trim();",
      "    r.trim();",
      "    return {q, r / norm};",
      "  }",
      "",
      "  friend BigInt sqrt(const BigInt &a1) {",
      "    BigInt a = a1;",
      "    while (a.z.empty() || a.z.size() % 2 == 1) a.z.push_back(0);",
      "",
      "    int n = a.z.size();",
      "",
      "    int firstDigit = (int) ::sqrt((double) a.z[n - 1] * base + a.z[n - 2]);",
      "    int norm = base / (firstDigit + 1);",
      "    a *= norm;",
      "    a *= norm;",
      "    while (a.z.empty() || a.z.size() % 2 == 1) a.z.push_back(0);",
      "",
      "    BigInt r = (long long) a.z[n - 1] * base + a.z[n - 2];",
      "    firstDigit = (int) ::sqrt((double) a.z[n - 1] * base + a.z[n - 2]);",
      "    int q = firstDigit;",
      "    BigInt res;",
      "",
      "    for (int j = n / 2 - 1; j >= 0; j--) {",
      "      for (;; --q) {",
      "        BigInt r1 = (r - (res * 2 * base + q) * q) * base * base +",
      "                    (j > 0 ? (long long) a.z[2 * j - 1] * base + a.z[2 * j - 2] : 0);",
      "        if (r1 >= 0) {",
      "          r = r1;",
      "          break;",
      "        }",
      "      }",
      "      res *= base;",
      "      res += q;",
      "",
      "      if (j > 0) {",
      "        int d1 = res.z.size() + 2 < r.z.size() ? r.z[res.z.size() + 2] : 0;",
      "        int d2 = res.z.size() + 1 < r.z.size() ? r.z[res.z.size() + 1] : 0;",
      "        int d3 = res.z.size() < r.z.size() ? r.z[res.z.size()] : 0;",
      "        q = (int) (((long long) d1 * base * base + (long long) d2 * base + d3) / (firstDigit * 2));",
      "      }",
      "    }",
      "",
      "    res.trim();",
      "    return res / norm;",
      "  }",
      "",
      "  BigInt operator/(const BigInt &v) const { return divmod(*this, v).first; }",
      "",
      "  BigInt operator%(const BigInt &v) const { return divmod(*this, v).second; }",
      "",
      "  BigInt &operator/=(int v) {",
      "    if (v < 0) sign = -sign, v = -v;",
      "    for (int i = (int) z.size() - 1, rem = 0; i >= 0; --i) {",
      "      long long cur = z[i] + rem * (long long) base;",
      "      z[i] = (int) (cur / v);",
      "      rem = (int) (cur % v);",
      "    }",
      "    trim();",
      "    return *this;",
      "  }",
      "",
      "  BigInt operator/(int v) const { return BigInt(*this) /= v; }",
      "",
      "  int operator%(int v) const {",
      "    if (v < 0) v = -v;",
      "    int m = 0;",
      "    for (int i = (int) z.size() - 1; i >= 0; --i) m = (int) ((z[i] + m * (long long) base) % v);",
      "    return m * sign;",
      "  }",
      "",
      "  BigInt &operator*=(const BigInt &v) {",
      "    *this = *this * v;",
      "    return *this;",
      "  }",
      "",
      "  BigInt &operator/=(const BigInt &v) {",
      "    *this = *this / v;",
      "    return *this;",
      "  }",
      "",
      "  BigInt &operator%=(const BigInt &v) {",
      "    *this = *this % v;",
      "    return *this;",
      "  }",
      "",
      "  bool operator<(const BigInt &v) const {",
      "    if (sign != v.sign) return sign < v.sign;",
      "    if (z.size() != v.z.size()) return z.size() * sign < v.z.size() * v.sign;",
      "    for (int i = (int) z.size() - 1; i >= 0; i--)",
      "      if (z[i] != v.z[i]) return z[i] * sign < v.z[i] * sign;",
      "    return false;",
      "  }",
      "",
      "  bool operator>(const BigInt &v) const { return v < *this; }",
      "",
      "  bool operator<=(const BigInt &v) const { return !(v < *this); }",
      "",
      "  bool operator>=(const BigInt &v) const { return !(*this < v); }",
      "",
      "  bool operator==(const BigInt &v) const { return sign == v.sign && z == v.z; }",
      "",
      "  bool operator!=(const BigInt &v) const { return !(*this == v); }",
      "",
      "  void trim() {",
      "    while (!z.empty() && z.back() == 0) z.pop_back();",
      "    if (z.empty()) sign = 1;",
      "  }",
      "",
      "  bool isZero() const { return z.empty(); }",
      "",
      "  friend BigInt operator-(BigInt v) {",
      "    if (!v.z.empty()) v.sign = -v.sign;",
      "    return v;",
      "  }",
      "",
      "  BigInt abs() const { return sign == 1 ? *this : -*this; }",
      "",
      "  long long longValue() const {",
      "    long long res = 0;",
      "    for (int i = (int) z.size() - 1; i >= 0; i--) res = res * base + z[i];",
      "    return res * sign;",
      "  }",
      "",
      "  friend BigInt gcd(const BigInt &a, const BigInt &b) { return b.isZero() ? a : gcd(b, a % b); }",
      "",
      "  friend BigInt lcm(const BigInt &a, const BigInt &b) { return a / gcd(a, b) * b; }",
      "",
      "  void read(const std::string &s) {",
      "    sign = 1;",
      "    z.clear();",
      "    int pos = 0;",
      "    while (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {",
      "      if (s[pos] == '-') sign = -sign;",
      "      ++pos;",
      "    }",
      "    for (int i = (int) s.size() - 1; i >= pos; i -= base_digits) {",
      "      int x = 0;",
      "      for (int j = std::max(pos, i - base_digits + 1); j <= i; j++) x = x * 10 + s[j] - '0';",
      "      z.push_back(x);",
      "    }",
      "    trim();",
      "  }",
      "",
      "  friend std::istream &operator>>(std::istream &stream, BigInt &v) {",
      "    std::string s;",
      "    stream >> s;",
      "    v.read(s);",
      "    return stream;",
      "  }",
      "",
      "  friend std::ostream &operator<<(std::ostream &stream, const BigInt &v) {",
      "    if (v.sign == -1) stream << '-';",
      "    stream << (v.z.empty() ? 0 : v.z.back());",
      "    for (int i = (int) v.z.size() - 2; i >= 0; --i) stream << std::setw(base_digits) << std::setfill('0') << v.z[i];",
      "    return stream;",
      "  }",
      "",
      "  static std::vector<int> convert_base(const std::vector<int> &a, int old_digits, int new_digits) {",
      "    std::vector<long long> p(std::max(old_digits, new_digits) + 1);",
      "    p[0] = 1;",
      "    for (int i = 1; i < (int) p.size(); i++) p[i] = p[i - 1] * 10;",
      "    std::vector<int> res;",
      "    long long cur = 0;",
      "    int cur_digits = 0;",
      "    for (int v : a) {",
      "      cur += v * p[cur_digits];",
      "      cur_digits += old_digits;",
      "      while (cur_digits >= new_digits) {",
      "        res.push_back(int(cur % p[new_digits]));",
      "        cur /= p[new_digits];",
      "        cur_digits -= new_digits;",
      "      }",
      "    }",
      "    res.push_back((int) cur);",
      "    while (!res.empty() && res.back() == 0) res.pop_back();",
      "    return res;",
      "  }",
      "",
      "  BigInt operator*(const BigInt &v) const {",
      "    if (std::min(z.size(), v.z.size()) < 150) return mul_simple(v);",
      "    BigInt res;",
      "    res.sign = sign * v.sign;",
      "    res.z = multiply_bigint(convert_base(z, base_digits, fft_base_digits),",
      "                            convert_base(v.z, base_digits, fft_base_digits), fft_base);",
      "    res.z = convert_base(res.z, fft_base_digits, base_digits);",
      "    res.trim();",
      "    return res;",
      "  }",
      "",
      "  BigInt mul_simple(const BigInt &v) const {",
      "    BigInt res;",
      "    res.sign = sign * v.sign;",
      "    res.z.resize(z.size() + v.z.size());",
      "    for (int i = 0; i < (int) z.size(); ++i)",
      "      if (z[i])",
      "        for (int j = 0, carry = 0; j < (int) v.z.size() || carry; ++j) {",
      "          long long cur = res.z[i + j] + (long long) z[i] * (j < (int) v.z.size() ? v.z[j] : 0) + carry;",
      "          carry = (int) (cur / base);",
      "          res.z[i + j] = (int) (cur % base);",
      "        }",
      "    res.trim();",
      "    return res;",
      "  }",
      "};",
      "}  // namespace BigInteger",
      "",
      "using BigInteger::BigInt;"
    ],
    "description": "bigint"
  },
  "comb": {
    "prefix": "comb",
    "body": [
      "template <typename M>",
      "struct Comb {",
      "  std::vector<M> _fact, _finv;",
      "",
      "  Comb() : _fact(1, 1), _finv(1, 1) {}",
      "",
      "  inline int size() const { return static_cast<int>(_fact.size()); }",
      "",
      "  void _double_extend() {",
      "    int old_size = size();",
      "    int new_size = std::min(M::mod(), size() * 2);",
      "",
      "    _fact.resize(new_size);",
      "    _finv.resize(new_size);",
      "",
      "    for (int i = old_size; i < new_size; i++) {",
      "      _fact[i] = _fact[i - 1] * i;",
      "    }",
      "",
      "    _finv[new_size - 1] = _fact[new_size - 1].inv();",
      "    for (int i = new_size - 2; i >= old_size; i--) {",
      "      _finv[i] = _finv[i + 1] * (i + 1);",
      "    }",
      "  }",
      "",
      "  M operator()(int n, int k) {",
      "    if (k > n || k < 0) return M();",
      "    while (size() <= n) {",
      "      _double_extend();",
      "    }",
      "    return _fact[n] * _finv[n - k] * _finv[k];",
      "  }",
      "",
      "  M lucas(int64_t n, int64_t k) {",
      "    if (k > n) return 0;",
      "    if (n < md) return this->operator()(n, k);",
      "    return lucas(n / md, k / md) * this->operator()(n % md, k % md);",
      "  }",
      "};"
    ],
    "description": "comb"
  },
  "dsu": {
    "prefix": "dsu",
    "body": [
      "struct DisjointSet {",
      "  std::vector<int> e;",
      "",
      "  DisjointSet(int n) { init(n); }",
      "",
      "  void init(int n) { e.assign(n, -1); }",
      "",
      "  int find(int u) { return e[u] < 0 ? u : e[u] = find(e[u]); }",
      "",
      "  bool merge(int u, int v) {",
      "    u = find(u), v = find(v);",
      "    if (u == v) return false;",
      "    if (e[u] > e[v]) std::swap(u, v);",
      "    e[u] += e[v];",
      "    e[v] = u;",
      "    return true;",
      "  }",
      "",
      "  bool is_connected(int u, int v) { return find(u) == find(v); }",
      "",
      "  int size(int u) { return -e[find(u)]; }",
      "};"
    ],
    "description": "dsu"
  },
  "fenwick": {
    "prefix": "fenwick",
    "body": [
      "",
      "template <typename T>",
      "struct FenwickTree {",
      "  int n;",
      "  std::vector<T> tree;",
      "",
      "  FenwickTree(int _n) : n(_n), tree(n + 1) {}",
      "",
      "  void update(int p, T v) {",
      "    for (++p; p <= n; p += p & -p) {",
      "      tree[p] += v;",
      "    }",
      "  }",
      "",
      "  T get(int p) {",
      "    T v{};",
      "    for (++p; p > 0; p -= p & -p) {",
      "      v += tree[p];",
      "    }",
      "    return v;",
      "  }",
      "};",
      "",
      "struct Node {",
      "  int64_t v = 0;",
      "",
      "  Node& operator+=(const Node& rhs) {",
      "    v += rhs.v;",
      "  }",
      "};"
    ],
    "description": "fenwick"
  },
  "itseg": {
    "prefix": "itseg",
    "body": [
      "",
      "template <typename T, typename F = std::plus<T>>",
      "struct IterativeSegmentTree {",
      "  int n;",
      "  std::vector<T> tree;",
      "",
      "  IterativeSegmentTree() {}",
      "  IterativeSegmentTree(int _n) { init(_n); }",
      "",
      "  void init(int _n) {",
      "    n = _n;",
      "    tree.assign(2 * n, T());",
      "  }",
      "",
      "  template <typename Vec>",
      "  void build(const Vec& v) {",
      "    init(v.size());",
      "    for (int i = n; i < 2 * n; i++) tree[i] = T::from_value(v[i - n]);",
      "    for (int i = n - 1; i > 0; i--)",
      "      tree[i] = F()(tree[i << 1], tree[i << 1 | 1]);",
      "  }",
      "",
      "  template <typename Vec>",
      "  IterativeSegmentTree(const Vec& a) {",
      "    build(a);",
      "  }",
      "",
      "  void modify(int p, const T& v) {",
      "    for (tree[p += n] = v; p >>= 1;) {",
      "      tree[p] = F()(tree[p << 1], tree[p << 1 | 1]);",
      "    }",
      "  }",
      "",
      "  T query(int l, int r) {",
      "    T resl = T(), resr = T();",
      "    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {",
      "      if (l & 1) resl = F()(resl, tree[l++]);",
      "      if (r & 1) resr = F()(tree[--r], resr);",
      "    }",
      "    return F()(resl, resr);",
      "  }",
      "",
      "  T get(int i) const {",
      "    return tree[i + n];",
      "  }",
      "};",
      "",
      "struct Info {",
      "  int64_t v = 0;",
      "",
      "  static Info from_value(int64_t x) {",
      "    return {x};",
      "  }",
      "",
      "  friend Info operator+(const Info& l, const Info& r) {",
      "    return {l.v + r.v};",
      "  }",
      "};"
    ],
    "description": "itseg"
  },
  "lca_constant": {
    "prefix": "lca_constant",
    "body": [
      "",
      "template <typename T, typename F>",
      "struct SparseTable {",
      "  std::vector<std::vector<T>> t;",
      "",
      "  SparseTable() {}",
      "  SparseTable(const std::vector<T>& a) : t(std::__lg(a.size()) + 1) {",
      "    t[0] = a;",
      "    for (int k = 0; k + 1 < (int)t.size(); k++) {",
      "      t[k + 1].resize(a.size() - (1 << (k + 1)) + 1);",
      "      for (int i = 0; i < (int)t[k + 1].size(); i++)",
      "        t[k + 1][i] = F()(t[k][i], t[k][i + (1 << k)]);",
      "    }",
      "  }",
      "",
      "  // NOTE: [l, r)",
      "  T query(int l, int r) const {",
      "    int k = std::__lg(r - l);",
      "    return F()(t[k][l], t[k][r - (1 << k)]);",
      "  }",
      "};",
      "",
      "template <typename T>",
      "struct MinMerge {",
      "  T operator()(const T& a, const T& b) { return std::min<T>(a, b); }",
      "};",
      "",
      "struct LCATree {",
      "  const int N;",
      "  std::vector<std::vector<std::pair<int, int>>> adj;",
      "",
      "  std::vector<int> st;",
      "  std::vector<int64_t> dist;",
      "  std::vector<std::pair<int, int>> euler;",
      "",
      "  SparseTable<std::pair<int, int>, MinMerge<std::pair<int, int>>> rmq;",
      "",
      "  LCATree(int V = 0) : N(V), adj(V), st(N), dist(N), euler(2 * N - 1) {}",
      "",
      "  void add_edge(int u, int v, int w) {",
      "    adj[u].emplace_back(v, w);",
      "    adj[v].emplace_back(u, w);",
      "  }",
      "",
      "  void dfs(int u, int p, int d, int& ti) {",
      "    st[u] = ti;",
      "    euler[ti++] = {d, u};",
      "    for (auto [v, w] : adj[u]) {",
      "      if (v == p) continue;",
      "      dist[v] = dist[u] + w;",
      "      dfs(v, u, d + 1, ti);",
      "      euler[ti++] = {d, u};",
      "    }",
      "  }",
      "",
      "  void build(int root = 0) {",
      "    int ti = 0;",
      "    dist[root] = 0;",
      "    dfs(root, root, 0, ti);",
      "    rmq = euler;",
      "  }",
      "",
      "  int lca(int u, int v) const {",
      "    int l = st[u], r = st[v];",
      "    if (l > r) std::swap(l, r);",
      "    return rmq.query(l, r + 1).second;",
      "  }",
      "",
      "  int64_t path_length(int u, int v) const {",
      "    return dist[u] + dist[v] - dist[lca(u, v)] * 2;",
      "  }",
      "};"
    ],
    "description": "lca_constant"
  },
  "linedeque": {
    "prefix": "linedeque",
    "body": [
      "template <bool kGetMin = false>",
      "struct LineDeque {",
      "  using T = long long;",
      "",
      "  struct Line {",
      "    mutable T a, b, p;",
      "    bool operator<(const Line& other) const { return a < other.a; }",
      "    bool operator<(T x) const { return p < x; }",
      "    T eval(T x) const { return a * x + b; }",
      "  };",
      "",
      "  using Set = std::deque<Line>;",
      "  using Iterator = typename Set::iterator;",
      "  Set s;",
      "",
      "  static const T inf = std::numeric_limits<T>::max();",
      "",
      "  // doubles: inf = 1/.0, div(a, b) = a / b",
      "  T div(T a, T b) {  // floored division",
      "    return a / b - ((a ^ b) < 0 && a % b);",
      "  }",
      "",
      "  bool intersect(Line& x, Line& y) {",
      "    if (x.a == y.a) {",
      "      x.p = x.b > y.b ? inf : -inf;",
      "    } else {",
      "      x.p = div(y.b - x.b, x.a - y.a);",
      "    }",
      "    return x.p >= y.p;",
      "  }",
      "",
      "  void _add_line1(T a, T b) { // increasing slope",
      "    Line to_add = {a, b, inf};",
      "    if (s.size()) {",
      "      intersect(s.back(), to_add);",
      "    }",
      "    while (s.size() >= 2 && intersect(s.at(s.size() - 2), s.at(s.size() - 1))) {",
      "      s.pop_back();",
      "      intersect(s.back(), to_add);",
      "    }",
      "    s.push_back(to_add);",
      "  }",
      "",
      "  void _add_line2(T a, T b) { // decreasing slope",
      "    Line to_add = {a, b, 0};",
      "    while (s.size() && intersect(to_add, s.front())) {",
      "      s.pop_front();",
      "    }",
      "    s.push_front(to_add);",
      "  }",
      "",
      "  void add_line_increasing_slope(T a, T b) {",
      "    if constexpr (kGetMin) {",
      "      _add_line2(-a, -b);",
      "    } else {",
      "      _add_line1(a, b);",
      "    }",
      "  }",
      "",
      "  void add_line_decreasing_slope(T a, T b) {",
      "    if constexpr (kGetMin) {",
      "      _add_line1(-a, -b);",
      "    } else {",
      "      _add_line2(a, b);",
      "    }",
      "  }",
      "",
      "  T query(T x) { // arbitrary",
      "    assert(!s.empty());",
      "    auto l = *std::lower_bound(s.begin(), s.end(), x);",
      "    // To get min",
      "    if constexpr (kGetMin) {",
      "      return -l.eval(x);",
      "    } else {",
      "      return l.eval(x);",
      "    }",
      "  }",
      "",
      "  T query_increasing(T x) {",
      "    while (s.size() >= 2 && s[0].eval(x) <= s[1].eval(x)) {",
      "      s.pop_front();",
      "    }",
      "    if constexpr (kGetMin) {",
      "      return -s[0].eval(x);",
      "    } else {",
      "      return s[0].eval(x);",
      "    }",
      "  }",
      "",
      "  T query_decreasing(T x) {",
      "    while (s.size() >= 2 && s.at(s.size() - 1).eval(x) <= s.at(s.size() - 2).eval(x)) {",
      "      s.pop_back();",
      "    }",
      "    if constexpr (kGetMin) {",
      "      return -s.back().eval(x);",
      "    } else {",
      "      return s.back().eval(x);",
      "    }",
      "  }",
      "};"
    ],
    "description": "linedeque"
  },
  "lineset": {
    "prefix": "lineset",
    "body": [
      "template <bool kGetMin = false>",
      "struct LineMultiset {",
      "  using T = long long;",
      "",
      "  struct Line {",
      "    mutable T a, b, p;",
      "    bool operator<(const Line& other) const { return a < other.a; }",
      "    bool operator<(T x) const { return p < x; }",
      "  };",
      "",
      "  using Set = std::multiset<Line, std::less<>>;",
      "  using Iterator = typename Set::iterator;",
      "  Set s;",
      "",
      "  static const T inf = std::numeric_limits<T>::max();",
      "",
      "  // doubles: inf = 1/.0, div(a, b) = a / b",
      "  T div(T a, T b) {  // floored division",
      "    return a / b - ((a ^ b) < 0 && a % b);",
      "  }",
      "",
      "  bool intersect(Iterator x, Iterator y) {",
      "    if (y == s.end()) return x->p = inf, 0;",
      "    if (x->a == y->a)",
      "      x->p = x->b > y->b ? inf : -inf;",
      "    else",
      "      x->p = div(y->b - x->b, x->a - y->a);",
      "    return x->p >= y->p;",
      "  }",
      "",
      "  // Adding line y = ax + b",
      "  void add_line(T a, T b) {",
      "    if constexpr (kGetMin) {",
      "      a = -a, b = -b;",
      "    }",
      "    auto z = s.insert({a, b, 0}), y = z++, x = y;",
      "    while (intersect(y, z)) z = s.erase(z);",
      "    if (x != s.begin() && intersect(--x, y)) intersect(x, y = s.erase(y));",
      "    while ((y = x) != s.begin() && (--x)->p >= y->p) intersect(x, s.erase(y));",
      "  }",
      "",
      "  T query(T x) {",
      "    assert(!s.empty());",
      "    auto l = *s.lower_bound(x);",
      "    // To get min",
      "    if constexpr (kGetMin) {",
      "      return -l.a * x - l.b;",
      "    } else {",
      "      return l.a * x + l.b;",
      "    }",
      "  }",
      "};"
    ],
    "description": "lineset"
  },
  "modint": {
    "prefix": "modint",
    "body": [
      "template <int md>",
      "struct Modular {",
      "  int v;",
      "",
      "  constexpr Modular() : v(0) {}",
      "",
      "  template <typename T>",
      "  static inline int normalize(const T& x) {",
      "    int res = -mod() <= x && x < mod() ? static_cast<int>(x) : static_cast<int>(x % mod());",
      "    return res + (res < 0) * mod();",
      "  }",
      "",
      "  static constexpr int mod() {",
      "    return md;",
      "  }",
      "",
      "  template <typename U>",
      "  Modular(const U& x) : v(normalize(x)) {}",
      "",
      "  const int& operator()() const { return v; }",
      "",
      "  template <typename U>",
      "  explicit operator U() const {",
      "    return static_cast<U>(v);",
      "  }",
      "",
      "  using M = Modular;",
      "",
      "  template <typename U>",
      "  friend std::enable_if_t<std::is_integral_v<U>, M> power(M b, U e) {",
      "    assert(e >= 0);",
      "    M ans = 1;",
      "    while (e) {",
      "      if (e & 1) ans *= b;",
      "      b *= b;",
      "      e >>= 1;",
      "    }",
      "    return ans;",
      "  }",
      "",
      "  M inv() const {",
      "    M res = power(*this, mod() - 2);",
      "    return res;",
      "  }",
      "",
      "  M& operator+=(const M& y) { return v += y.v, v -= (v >= mod()) * mod(), *this; }",
      "  M& operator-=(const M& y) { return v -= y.v, v += (v < 0) * mod(), *this; }",
      "  M& operator*=(const M& y) { return v = (int64_t) v * y.v % mod(), *this; }",
      "  M& operator/=(const M& y) { return *this *= y.inv(); }",
      "",
      "  M& operator++() { return v++, v -= (v >= mod()) * mod(), *this; }",
      "  M& operator--() { return v--, v += (v < 0) * mod(), *this; }",
      "",
      "  M operator++(int) {",
      "    M res(*this);",
      "    return ++(*this), res;",
      "  }",
      "  M operator--(int) {",
      "    M res(*this);",
      "    return --(*this), res;",
      "  }",
      "",
      "  M operator+() const { return *this; }",
      "  M operator-() const { return M() - *this; }",
      "",
      "  friend bool operator==(const M& x, const M& y) { return x.v == y.v; }",
      "  friend bool operator<(const M& x, const M& y) { return x.v < y.v; }",
      "  friend bool operator>(const M& x, const M& y) { return x.v > y.v; }",
      "  friend bool operator<=(const M& x, const M& y) { return x.v <= y.v; }",
      "  friend bool operator>=(const M& x, const M& y) { return x.v >= y.v; }",
      "  friend bool operator!=(const M& x, const M& y) { return x.v != y.v; }",
      "",
      "  template <typename Istream>",
      "  friend Istream& operator>>(Istream& is, M& y) {",
      "    int64_t x;",
      "    is >> x;",
      "    y.v = y.normalize(x);",
      "    return is;",
      "  }",
      "",
      "  template <typename Ostream>",
      "  friend Ostream& operator<<(Ostream& os, const M& y) {",
      "    return os << y.v;",
      "  }",
      "",
      "  friend M operator+(const M& x, const M& y) { return M(x) += y; }",
      "  friend M operator-(const M& x, const M& y) { return M(x) -= y; }",
      "  friend M operator*(const M& x, const M& y) { return M(x) *= y; }",
      "  friend M operator/(const M& x, const M& y) { return M(x) /= y; }",
      "};",
      "",
      "constexpr int md = 1e9 + 7;",
      "using Mint = Modular<md>;"
    ],
    "description": "modint"
  },
  "ordset": {
    "prefix": "ordset",
    "body": [
      "",
      "#include <ext/pb_ds/assoc_container.hpp>  // Common file",
      "#include <ext/pb_ds/tree_policy.hpp>\t  // Including tree_order_statistics_node_update",
      "",
      "using namespace __gnu_pbds;",
      "",
      "// for multiset, change less -> less_equal",
      "template <typename T>",
      "using ordered_set = tree<T, null_type, std::less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
      "",
      "// int main() {",
      "//   ordered_set X;",
      "//   // X = {1, 2, 4, 8, 16}",
      "//   for (int i = 1; i <= 16; i *= 2)",
      "//     X.insert(i);",
      "//   cout << *X.find_by_order(0) << endl;\t\t\t  // 1",
      "//   cout << *X.find_by_order(1) << endl;\t\t\t  // 2",
      "//   cout << *X.find_by_order(2) << endl;\t\t\t  // 4",
      "//   cout << *X.find_by_order(4) << endl;\t\t\t  // 16",
      "//   cout << (X.end() == X.find_by_order(6)) << endl;  // true",
      "",
      "//   cout << X.order_of_key(-5) << endl;   // 0",
      "//   cout << X.order_of_key(1) << endl;\t// 0",
      "//   cout << X.order_of_key(3) << endl;\t// 2",
      "//   cout << X.order_of_key(4) << endl;\t// 2",
      "//   cout << X.order_of_key(400) << endl;  // 5",
      "// }"
    ],
    "description": "ordset"
  },
  "perseg": {
    "prefix": "perseg",
    "body": [
      "struct PersistentSegmentTree {",
      "  struct Node {",
      "    int l = 0, r = 0;",
      "    int64_t v = 0;",
      "  };",
      "",
      "  int n;",
      "  std::vector<Node> t = {Node()};",
      "",
      "  PersistentSegmentTree() {}",
      "  PersistentSegmentTree(int _n) : n(_n) {}",
      "",
      "  inline int copy(int k) { return t.emplace_back(t[k]), t.size() - 1; }",
      "",
      "  int update(int k, int l, int r, int p, int v) {",
      "    int id = copy(k);",
      "    if (l == r) {",
      "      t[id].v = v;",
      "      return id;",
      "    }",
      "    int mid = (l + r) / 2;",
      "    if (p <= mid) {",
      "      int ll = update(t[id].l, l, mid, p, v);",
      "      t[id].l = ll;",
      "    } else {",
      "      int rr = update(t[id].r, mid + 1, r, p, v);",
      "      t[id].r = rr;",
      "    }",
      "    t[id].v = t[t[id].l].v + t[t[id].r].v;",
      "    return id;",
      "  }",
      "",
      "  int64_t query(int k, int l, int r, int qL, int qR) {",
      "    if (l > qR | r < qL) return 0;",
      "    if (qL <= l && r <= qR) return t[k].v;",
      "    int mid = (l + r) / 2;",
      "    return query(t[k].l, l, mid, qL, qR) + query(t[k].r, mid + 1, r, qL, qR);",
      "  }",
      "",
      "  int64_t query(int k, int l, int r) { return query(k, 0, n - 1, l, r); }",
      "",
      "  int update(int k, int p, int v) { return update(k, 0, n - 1, p, v); }",
      "};"
    ],
    "description": "perseg"
  },
  "segtree": {
    "prefix": "segtree",
    "body": [
      "template <typename T, typename L, typename F = std::plus<T>>",
      "struct SegmentTree {",
      "  int n;",
      "  std::vector<T> tree;",
      "  std::vector<L> lazy;",
      "",
      "  SegmentTree() {}",
      "  SegmentTree(int _n) { init(_n); }",
      "",
      "  void init(int _n) {",
      "    n = _n;",
      "    tree.assign(2 * n - 1, T());",
      "    lazy.assign(2 * n - 1, L());",
      "  }",
      "",
      "  template <typename Vec>",
      "  void build(int x, int l, int r, const Vec& v) {",
      "    if (l == r - 1) {",
      "      tree[x] = T::from_value(v[l]);",
      "      return;",
      "    }",
      "",
      "    int m = (l + r) / 2, y = x + 1, z = x + (m - l) * 2;",
      "    build(y, l, m, v);",
      "    build(z, m, r, v);",
      "    tree[x] = F()(tree[y], tree[z]);",
      "  }",
      "",
      "  template <typename Vec>",
      "  void build(const Vec& v) {",
      "    init(v.size());",
      "    build(0, 0, n, v);",
      "  }",
      "",
      "  template <typename Vec>",
      "  SegmentTree(const Vec& v) {",
      "    build(v);",
      "  }",
      "",
      "  inline void apply(int x, const L& t) {",
      "    tree[x].apply(t);",
      "    lazy[x].apply(t);",
      "  }",
      "",
      "  inline void push(int x, int y, int z) {",
      "    apply(y, lazy[x]);",
      "    apply(z, lazy[x]);",
      "    lazy[x] = L();",
      "  }",
      "",
      "  inline void pull(int x, int y, int z) {",
      "    tree[x] = F()(tree[y], tree[z]);",
      "  }",
      "",
      "  void modify(int x, int l, int r, int p, const T& v) {",
      "    if (l == r - 1) {",
      "      tree[x] = v;",
      "      return;",
      "    }",
      "    int m = (l + r) / 2, y = x + 1, z = x + (m - l) * 2;",
      "    push(x, y, z);",
      "    if (p < m)",
      "      modify(y, l, m, p, v);",
      "    else",
      "      modify(z, m, r, p, v);",
      "    pull(x, y, z);",
      "  }",
      "",
      "  void range_apply(int x, int l, int r, int ql, int qr, const L& t) {",
      "    if (ql <= l && r <= qr) {",
      "      apply(x, t);",
      "      return;",
      "    }",
      "    int m = (l + r) / 2, y = x + 1, z = x + (m - l) * 2;",
      "    push(x, y, z);",
      "    if (m > ql) range_apply(y, l, m, ql, qr, t);",
      "    if (m < qr) range_apply(z, m, r, ql, qr, t);",
      "    pull(x, y, z);",
      "  }",
      "",
      "  T range_query(int x, int l, int r, int ql, int qr) {",
      "    if (ql <= l && r <= qr) {",
      "      return tree[x];",
      "    }",
      "    int m = (l + r) / 2, y = x + 1, z = x + (m - l) * 2;",
      "    push(x, y, z);",
      "    if (m <= ql) return range_query(z, m, r, ql, qr);",
      "    if (m >= qr) return range_query(y, l, m, ql, qr);",
      "    return F()(range_query(y, l, m, ql, qr), range_query(z, m, r, ql, qr));",
      "  }",
      "",
      "  inline void modify(int p, const T& v) {",
      "    assert(0 <= p && p < n);",
      "    modify(0, 0, n, p, v);",
      "  }",
      "  // NOTE: [l, r)",
      "  inline void range_apply(int l, int r, const L& t) {",
      "    assert(0 <= l && l < r && r <= n);",
      "    range_apply(0, 0, n, l, r, t);",
      "  }",
      "  // NOTE: [l, r)",
      "  inline T range_query(int l, int r) {",
      "    assert(0 <= l && l < r && r <= n);",
      "    return range_query(0, 0, n, l, r);",
      "  }",
      "};",
      "",
      "struct Tag {",
      "  int64_t v = 0;",
      "",
      "  inline void apply(const Tag& t) {",
      "    v += t.v;",
      "  }",
      "};",
      "",
      "struct Info {",
      "  int64_t v = -1e18;",
      "",
      "",
      "  inline void apply(const Tag& t) {",
      "    v += t.v;",
      "  }",
      "",
      "  friend Info operator+(const Info& l, const Info& r) {",
      "    return {std::max(l.v, r.v)};",
      "  }",
      "};"
    ],
    "description": "segtree"
  },
  "sparsetable": {
    "prefix": "sparsetable",
    "body": [
      "template <typename T, typename F>",
      "struct SparseTable {",
      "  std::vector<std::vector<T>> t;",
      "",
      "  SparseTable() {}",
      "  SparseTable(const std::vector<T>& a) : t(std::__lg(a.size()) + 1) {",
      "    t[0] = a;",
      "    for (int k = 0; k + 1 < (int)t.size(); k++) {",
      "      t[k + 1].resize(a.size() - (1 << (k + 1)) + 1);",
      "      for (int i = 0; i < (int)t[k + 1].size(); i++)",
      "        t[k + 1][i] = F()(t[k][i], t[k][i + (1 << k)]);",
      "    }",
      "  }",
      "",
      "  // NOTE: [l, r)",
      "  T query(int l, int r) const {",
      "    int k = std::__lg(r - l);",
      "    return F()(t[k][l], t[k][r - (1 << k)]);",
      "  }",
      "};",
      "",
      "template <typename T>",
      "struct MinMerge {",
      "  T operator()(const T& a, const T& b) { return std::min<T>(a, b); }",
      "};"
    ],
    "description": "sparsetable"
  },
  "bimatching": {
    "prefix": "bimatching",
    "body": [
      "struct HopcroftKarp {",
      "  int L, R;",
      "  std::vector<std::vector<int>> adj;",
      "  std::vector<int> matchL, matchR;",
      "  std::vector<int> root, prev, q;",
      "  int ans = 0;",
      "",
      "  HopcroftKarp(int _L, int _R) : L(_L), R(_R), adj(_L), matchL(L, -1), matchR(R, -1), root(L), prev(L), q(L) {}",
      "",
      "  void add_edge(int u, int v) {",
      "    adj[u].push_back(v);",
      "  }",
      "",
      "  int solve(bool stop = false) {",
      "    while (true) {",
      "      root.assign(L, -1);",
      "      prev.assign(L, -1);",
      "      int sz = 0;",
      "      for (int i = 0; i < L; i++) {",
      "        if (matchL[i] == -1) {",
      "          q[sz++] = i;",
      "          root[i] = prev[i] = i;",
      "        }",
      "      }",
      "",
      "      bool match = false;",
      "      for (int i = 0; i < sz; i++) {",
      "        int u = q[i];",
      "        if (matchL[root[u]] != -1) continue; // we don't need it anymore",
      "",
      "        for (int v : adj[u]) {",
      "          if (matchR[v] == -1) {",
      "            // we found it boys",
      "            while (v != -1) {",
      "              matchR[v] = u;",
      "              std::swap(matchL[u], v);",
      "              u = prev[u];",
      "            }",
      "            match = true;",
      "            ans++;",
      "            if (stop) return ans;",
      "            break;",
      "          }",
      "",
      "          if (prev[matchR[v]] == -1) {",
      "            // we can add it to queue",
      "            q[sz++] = matchR[v];",
      "            v = matchR[v];",
      "            prev[v] = u;",
      "            root[v] = root[u];",
      "          }",
      "        }",
      "      }",
      "",
      "      if (!match) break;",
      "    }",
      "",
      "    return ans;",
      "  }",
      "};"
    ],
    "description": "bimatching"
  },
  "mcmf": {
    "prefix": "mcmf",
    "body": [
      "struct MCMF {",
      "  const long long INF = 1e18;",
      "  struct Edge {",
      "    int u, v, flow, cap, cost;",
      "  };",
      "",
      "  int n, s, t;",
      "  std::vector<long long> dist, pot;",
      "  std::vector<int> prev;",
      "  std::vector<std::vector<int>> adj;",
      "  std::vector<Edge> edges;",
      "",
      "  MCMF() {}",
      "  MCMF(int n, int s, int t)",
      "      : n(n), s(s), t(t), dist(n), pot(n, 0), prev(n), adj(n) {}",
      "",
      "  void add_edge(int u, int v, int cap, int cost) {",
      "    adj[u].push_back(edges.size());",
      "    edges.push_back({u, v, 0, cap, cost});",
      "    adj[v].push_back(edges.size());",
      "    edges.push_back({v, u, 0, 0, -cost});",
      "  }",
      "",
      "  std::pair<long long, long long> dijkstra() {",
      "    dist.assign(n, INF);",
      "    dist[s] = 0;",
      "    prev[s] = -1;",
      "    std::priority_queue<std::pair<long long, int>> pq;",
      "    pq.push({0, s});",
      "    while (pq.size()) {",
      "      auto [d, u] = pq.top();",
      "      pq.pop();",
      "",
      "      if (-d > dist[u]) continue;",
      "",
      "      for (int eid : adj[u]) {",
      "        auto& [u, v, flow, cap, cost] = edges[eid];",
      "        if (flow >= cap) continue;",
      "        long long newDist = dist[u] + cost + pot[u] - pot[v];",
      "        if (newDist < dist[v]) {",
      "          dist[v] = newDist;",
      "          prev[v] = eid;",
      "          pq.push({-dist[v], v});",
      "        }",
      "      }",
      "    }",
      "",
      "    for (int i = 0; i < n; i++) pot[i] += dist[i];",
      "",
      "    if (dist[t] >= INF) return {0, 0};",
      "",
      "    long long flow = INF, cost = 0;",
      "    for (int id = prev[t]; id >= 0; id = prev[edges[id].u]) {",
      "      flow = std::min(flow, (long long)edges[id].cap - edges[id].flow);",
      "    }",
      "    for (int id = prev[t]; id >= 0; id = prev[edges[id].u]) {",
      "      cost += flow * edges[id].cost;",
      "      edges[id].flow += flow;",
      "      edges[id ^ 1].flow -= flow;",
      "    }",
      "    return {flow, cost};",
      "  }",
      "",
      "  std::pair<long long, long long> solve() {",
      "    long long flow = 0, cost = 0;",
      "    while (true) {",
      "      auto [nflow, ncost] = dijkstra();",
      "      if (dist[t] >= INF) break;",
      "      flow += nflow;",
      "      cost += ncost;",
      "    }",
      "    return {flow, cost};",
      "  }",
      "",
      "  std::vector<int> getPath() {",
      "    int u = s;",
      "    std::vector<int> path;",
      "    while (u != t) {",
      "      path.push_back(u);",
      "      bool check = false;",
      "      for (int eid : adj[u]) {",
      "        if (edges[eid].flow > 0) {",
      "          edges[eid].flow--;",
      "          u = edges[eid].v;",
      "          check = true;",
      "          break;",
      "        }",
      "      }",
      "      if (!check) break;",
      "    }",
      "    if (u != t)",
      "      path.clear();",
      "    else",
      "      path.push_back(u);",
      "    return path;",
      "  }",
      "",
      "  std::vector<std::vector<int>> getPaths() {",
      "    std::vector<std::vector<int>> res;",
      "    while (true) {",
      "      std::vector<int> path = getPath();",
      "      if (path.empty()) break;",
      "      res.push_back(path);",
      "    }",
      "    return res;",
      "  }",
      "};"
    ],
    "description": "mcmf"
  },
  "geometry": {
    "prefix": "geometry",
    "body": [
      "template <class F>",
      "struct Point {",
      "  F x, y;",
      "  Point() : x(0), y(0) {}",
      "  Point(const F& _x, const F& _y) : x(_x), y(_y) {}",
      "",
      "  void swap(Point& other) {",
      "    using std::swap;",
      "    swap(x, other.x);",
      "    swap(y, other.y);",
      "  }",
      "  template <class F1>",
      "  explicit operator Point<F1>() const {",
      "    return Point<F1>(static_cast<F1>(x), static_cast<F1>(y));",
      "  }",
      "  template <class F1>",
      "  Point& operator=(const Point<F1>& other) {",
      "    x = other.x;",
      "    y = other.y;",
      "    return *this;",
      "  }",
      "  template <class F1>",
      "  Point& operator+=(const Point<F1>& other) {",
      "    x += other.x;",
      "    y += other.y;",
      "    return *this;",
      "  }",
      "  template <class F1>",
      "  Point& operator-=(const Point<F1>& other) {",
      "    x -= other.x;",
      "    y -= other.y;",
      "    return *this;",
      "  }",
      "  template <class F1>",
      "  Point& operator*=(const F1& factor) {",
      "    x *= factor;",
      "    y *= factor;",
      "    return *this;",
      "  }",
      "  template <class F1>",
      "  Point& operator/=(const F1& factor) {",
      "    x /= factor;",
      "    y /= factor;",
      "    return *this;",
      "  }",
      "};",
      "",
      "template <class F>",
      "int read(Point<F>& point) {",
      "  return read(point.x, point.y) / 2;",
      "}",
      "template <class F>",
      "int write(const Point<F>& point) {",
      "  return write(point.x, point.y);",
      "}",
      "",
      "template <class F>",
      "std::istream& operator>>(std::istream& is, Point<F>& point) {",
      "  return is >> point.x >> point.y;",
      "}",
      "template <class F>",
      "std::ostream& operator<<(std::ostream& os, const Point<F>& point) {",
      "  return os << point.x << ' ' << point.y;",
      "}",
      "",
      "template <class F>",
      "inline Point<F> makePoint(const F& x, const F& y) {",
      "  return Point<F>(x, y);",
      "}",
      "template <class F>",
      "void swap(Point<F>& lhs, Point<F>& rhs) {",
      "  lhs.swap(rhs);",
      "}",
      "",
      "#define FUNC1(name, arg, expr)                    \\",
      "  template <class F>                              \\",
      "  inline auto name(const arg) -> decltype(expr) { \\",
      "    return expr;                                  \\",
      "  }",
      "#define FUNC2(name, arg1, arg2, expr)                          \\",
      "  template <class F1, class F2>                                \\",
      "  inline auto name(const arg1, const arg2) -> decltype(expr) { \\",
      "    return expr;                                               \\",
      "  }",
      "#define FUNC3(name, arg1, arg2, arg3, expr)                                \\",
      "  template <class F1, class F2, class F3>                                  \\",
      "  inline auto name(const arg1, const arg2, const arg3) -> decltype(expr) { \\",
      "    return expr;                                                           \\",
      "  }",
      "",
      "FUNC1(operator-, Point<F>& point, makePoint(-point.x, -point.y))",
      "FUNC2(operator+, Point<F1>& lhs, Point<F2>& rhs,",
      "      makePoint(lhs.x + rhs.x, lhs.y + rhs.y))",
      "FUNC2(operator-, Point<F1>& lhs, Point<F2>& rhs,",
      "      makePoint(lhs.x - rhs.x, lhs.y - rhs.y))",
      "FUNC2(operator*, F1& factor, Point<F2>& rhs,",
      "      makePoint(factor* rhs.x, factor* rhs.y))",
      "FUNC2(operator*, Point<F1>& lhs, F2& factor,",
      "      makePoint(lhs.x* factor, lhs.y* factor))",
      "FUNC2(operator/, Point<F1>& lhs, F2& factor,",
      "      makePoint(lhs.x / factor, lhs.y / factor))",
      "",
      "FUNC2(operator*, Point<F1>& lhs, Point<F2>& rhs, lhs.x* rhs.x + lhs.y * rhs.y)",
      "FUNC2(operator^, Point<F1>& lhs, Point<F2>& rhs, lhs.x* rhs.y - lhs.y * rhs.x)",
      "",
      "// < 0 if rhs <- lhs counter-clockwise, 0 if collinear, > 0 if clockwise.",
      "FUNC2(ccw, Point<F1>& lhs, Point<F2>& rhs, rhs ^ lhs)",
      "FUNC3(ccw, Point<F1>& lhs, Point<F2>& rhs, Point<F3>& origin,",
      "      ccw(lhs - origin, rhs - origin))",
      "",
      "FUNC2(operator==, Point<F1>& lhs, Point<F2>& rhs,",
      "      lhs.x == rhs.x && lhs.y == rhs.y)",
      "FUNC2(operator!=, Point<F1>& lhs, Point<F2>& rhs, !(lhs == rhs))",
      "",
      "FUNC2(operator<, Point<F1>& lhs, Point<F2>& rhs,",
      "      lhs.y < rhs.y || (lhs.y == rhs.y && lhs.x < rhs.x))",
      "FUNC2(operator>, Point<F1>& lhs, Point<F2>& rhs, rhs < lhs)",
      "FUNC2(operator<=, Point<F1>& lhs, Point<F2>& rhs, !(lhs > rhs))",
      "FUNC2(operator>=, Point<F1>& lhs, Point<F2>& rhs, !(lhs < rhs))",
      "",
      "// Angles and rotations (counter-clockwise).",
      "FUNC1(angle, Point<F>& point, atan2(point.y, point.x))",
      "FUNC2(angle, Point<F1>& lhs, Point<F2>& rhs, atan2(lhs ^ rhs, lhs* rhs))",
      "FUNC3(angle, Point<F1>& lhs, Point<F2>& rhs, Point<F3>& origin,",
      "      angle(lhs - origin, rhs - origin))",
      "FUNC3(rotate, Point<F1>& point, F2& angleSin, F3& angleCos,",
      "      makePoint(angleCos* point.x - angleSin * point.y,",
      "                angleSin* point.x + angleCos * point.y))",
      "FUNC2(rotate, Point<F1>& point, F2& angle,",
      "      rotate(point, sin(angle), cos(angle)))",
      "FUNC3(rotate, Point<F1>& point, F2& angle, Point<F3>& origin,",
      "      origin + rotate(point - origin, angle))",
      "FUNC1(perp, Point<F>& point, makePoint(-point.y, point.x))",
      "",
      "// Distances.",
      "FUNC1(abs, Point<F>& point, point* point)",
      "FUNC1(norm, Point<F>& point, sqrt(abs(point)))",
      "FUNC2(dist, Point<F1>& lhs, Point<F2>& rhs, norm(lhs - rhs))",
      "FUNC2(dist2, Point<F1>& lhs, Point<F2>& rhs, abs(lhs - rhs))",
      "FUNC2(bisector, Point<F1>& lhs, Point<F2>& rhs,",
      "      lhs* norm(rhs) + rhs * norm(lhs))",
      "",
      "#undef FUNC1",
      "#undef FUNC2",
      "#undef FUNC3",
      "",
      "template <class F>",
      "struct Line {",
      "  Point<F> a, ab;",
      "  Line() : a(), ab() {}",
      "  Line(const Point<F>& _a, const Point<F>& b, bool twoPoints = true)",
      "      : a(_a), ab(twoPoints ? b - a : b) {}",
      "  Line(const F& xa, const F& ya, const F& xb, const F& yb)",
      "      : a(xa, ya), ab(xb - xa, yb - ya) {}",
      "",
      "  void swap(Line& other) {",
      "    using std::swap;",
      "    swap(a, other.a);",
      "    swap(ab, other.ab);",
      "  }",
      "  template <class F1>",
      "  explicit operator Line<F1>() const {",
      "    return Line<F1>(Point<F1>(a), Point<F1>(ab), false);",
      "  }",
      "  template <class F1>",
      "  Line& operator=(const Line<F1>& other) {",
      "    a = other.a;",
      "    ab = other.ab;",
      "    return *this;",
      "  }",
      "",
      "  Point<F> b() const { return a + ab; }",
      "  operator bool() const { return ab != Point<F>(); }",
      "};",
      "",
      "template <class F>",
      "int read(Line<F>& line) {",
      "  int res = read(line.a, line.ab) / 2;",
      "  return line.ab -= line.a, res;",
      "}",
      "",
      "template <class F>",
      "inline Line<F> makeLine(const Point<F>& a, const Point<F>& b,",
      "                          bool twoPoints = true) {",
      "  return Line<F>(a, b, twoPoints);",
      "}",
      "",
      "template <class F>",
      "void swap(Line<F>& lhs, Line<F>& rhs) {",
      "  lhs.swap(rhs);",
      "}",
      "",
      "template <class F1, class F2>",
      "bool onLine(const Point<F1>& point, const Line<F2>& line) {",
      "  if (!line) return point == line.a;",
      "  return ((point - line.a) ^ line.ab) == 0;",
      "}",
      "",
      "template <class F1, class F2>",
      "bool onSegment(const Point<F1>& point, const Line<F2>& seg) {",
      "  if (!seg) return point == seg.a;",
      "  auto vecta = seg.a - point, vectb = seg.b() - point;",
      "  return (vecta ^ vectb) == 0 && (vecta * vectb) <= 0;",
      "}",
      "",
      "template <class F1, class F2>",
      "using distF = decltype(sqrt(F1() + F2()));",
      "",
      "template <class F1, class F2>",
      "distF<F1, F2> dist_line(const Point<F1>& point, const Line<F2>& line) {",
      "  if (!line) return dist(point, line.a);",
      "  return abs((point - line.a) ^ line.ab) / norm(line.ab);",
      "}",
      "",
      "template <class F1, class F2>",
      "distF<F1, F2> dist_segment(const Point<F1>& point, const Line<F2>& seg) {",
      "  if (((point - seg.a) * seg.ab) <= 0) return dist(point, seg.a);",
      "  if (((point - seg.b()) * seg.ab) >= 0) return dist(point, seg.b());",
      "  return dist_line(point, seg);",
      "}",
      "",
      "template <class F1, class F2, class F3>",
      "void projection(const Point<F1>& point, const Line<F2>& line,",
      "                Point<F3>& res) {",
      "  res = line.a;",
      "  if (line)",
      "    res += line.ab * static_cast<F3>((point - line.a) * line.ab) / abs(line.ab);",
      "}",
      "",
      "template <class F1, class F2, class F3>",
      "void reflection(const Point<F1>& point, const Line<F2>& line,",
      "                Point<F3>& res) {",
      "  projection(point, line, res);",
      "  res = 2 * res - point;",
      "}",
      "",
      "template <class F1, class F2, class F3>",
      "void closest(const Point<F1>& point, const Line<F2>& seg, Point<F3>& res) {",
      "  if (((point - seg.a) * seg.ab) <= 0)",
      "    res = seg.a;",
      "  else if (((point - seg.b()) * seg.ab) >= 0)",
      "    res = seg.b();",
      "  else",
      "    projection(point, seg, res);",
      "}",
      "",
      "template <int TYPE>",
      "struct EndpointChecker {};",
      "template <>",
      "struct EndpointChecker<0> {  // no endpoint (ray)",
      "  template <class F>",
      "  bool operator()(const F& a, const F& b) const {",
      "    return true;",
      "  }",
      "};",
      "template <>",
      "struct EndpointChecker<1> {  // closed endpoint",
      "  template <class F>",
      "  bool operator()(const F& a, const F& b) const {",
      "    return a <= b;",
      "  }",
      "};",
      "template <>",
      "struct EndpointChecker<2> {  // open endpoint",
      "  template <class F>",
      "  bool operator()(const F& a, const F& b) const {",
      "    return a < b;",
      "  }",
      "};",
      "",
      "template <int LA, int LB, int RA, int RB, class F1, class F2, class F3>",
      "bool intersect_lines(const Line<F1>& lhs, const Line<F2>& rhs,",
      "                    Point<F3>& res) {",
      "  assert(lhs && rhs);",
      "  auto s = lhs.ab ^ rhs.ab;",
      "  if (s == 0) return false;",
      "  auto ls = (rhs.a - lhs.a) ^ rhs.ab;",
      "  auto rs = (rhs.a - lhs.a) ^ lhs.ab;",
      "  if (s < 0) s = -s, ls = -ls, rs = -rs;",
      "  bool intersect = EndpointChecker<LA>()(decltype(ls)(0), ls) &&",
      "                   EndpointChecker<LB>()(ls, s) &&",
      "                   EndpointChecker<RA>()(decltype(rs)(0), rs) &&",
      "                   EndpointChecker<RB>()(rs, s);",
      "  if (intersect) res = lhs.a + lhs.ab * static_cast<F3>(ls) / s;",
      "  return intersect;",
      "}",
      "",
      "template <class F1, class F2, class F3>",
      "bool intersect_closed_segments(const Line<F1>& lhs, const Line<F2>& rhs,",
      "                             Point<F3>& res) {",
      "  return intersect_lines<1, 1, 1, 1>(lhs, rhs, res);",
      "}",
      "",
      "template <class F1, class F2, class F3>",
      "bool intersect_segments(const Line<F1>& lhs, const Line<F2>& rhs,",
      "                       Line<F3>& res) {",
      "  auto s = lhs.ab ^ rhs.ab;",
      "  auto ls = (rhs.a - lhs.a) ^ rhs.ab;",
      "  if (s == 0) {",
      "    if (ls != 0) return false;",
      "    auto lhsa = lhs.a, lhsb = lhs.b();",
      "    auto rhsa = rhs.a, rhsb = rhs.b();",
      "    if (lhsa > lhsb) swap(lhsa, lhsb);",
      "    if (rhsa > rhsb) swap(rhsa, rhsb);",
      "    res = Line<F3>(max(lhsa, rhsa), min(lhsb, rhsb));",
      "    return res.ab >= Point<F3>();",
      "  }",
      "  auto rs = (rhs.a - lhs.a) ^ lhs.ab;",
      "  if (s < 0) s = -s, ls = -ls, rs = -rs;",
      "  bool intersect = 0 <= ls && ls <= s && 0 <= rs && rs <= s;",
      "  if (intersect)",
      "    res = Line<F3>(lhs.a + lhs.ab * static_cast<F3>(ls) / s, Point<F3>());",
      "  return intersect;",
      "}",
      "",
      "template <class F>",
      "struct AngleCompare {",
      "  const Point<F> origin;",
      "  const bool zero;",
      "",
      "  AngleCompare(const Point<F>& _origin = Point<F>())",
      "      : origin(_origin), zero(origin == Point<F>()) {}",
      "",
      "  template <class F1, class F2>",
      "  bool operator()(const Point<F1>& lhs, const Point<F2>& rhs) const {",
      "    return zero ? ccw(lhs, rhs) < 0 : ccw(lhs, rhs, origin) < 0;",
      "  }",
      "};",
      "",
      "template <class Iterator, class F>",
      "void sort_by_angle(Iterator first, Iterator last, const Point<F>& origin) {",
      "  first = partition(first, last, [&origin](const decltype(*first)& point) {",
      "    return point == origin;",
      "  });",
      "  auto pivot = partition(first, last, [&origin](const decltype(*first)& point) {",
      "    return point > origin;",
      "  });",
      "  AngleCompare<F> acmp(origin);",
      "  sort(first, pivot, acmp);",
      "  sort(pivot, last, acmp);",
      "}"
    ],
    "description": "geometry"
  },
  "manhattanmst": {
    "prefix": "manhattanmst",
    "body": [
      "",
      "template <typename T>",
      "std::vector<std::tuple<T, int, int>> manhattan_mst(std::vector<T> xs,",
      "                                                   std::vector<T> ys) {",
      "  const int n = xs.size();",
      "  std::vector<int> idx(n);",
      "  std::iota(idx.begin(), idx.end(), 0);",
      "  std::vector<std::tuple<T, int, int>> ret;",
      "  for (int s = 0; s < 2; s++) {",
      "    for (int t = 0; t < 2; t++) {",
      "      auto cmp = [&](int i, int j) { return xs[i] + ys[i] < xs[j] + ys[j]; };",
      "      std::sort(idx.begin(), idx.end(), cmp);",
      "      std::map<T, int> sweep;",
      "      for (int i : idx) {",
      "        for (auto it = sweep.lower_bound(-ys[i]); it != sweep.end();",
      "             it = sweep.erase(it)) {",
      "          int j = it->second;",
      "          if (xs[i] - xs[j] < ys[i] - ys[j]) break;",
      "          ret.emplace_back(std::abs(xs[i] - xs[j]) + std::abs(ys[i] - ys[j]), i,",
      "                           j);",
      "        }",
      "        sweep[-ys[i]] = i;",
      "      }",
      "      std::swap(xs, ys);",
      "    }",
      "    for (auto &x : xs) x = -x;",
      "  }",
      "  std::sort(ret.begin(), ret.end());",
      "  return ret;",
      "}"
    ],
    "description": "manhattanmst"
  },
  "point": {
    "prefix": "point",
    "body": [
      "template <class F>",
      "struct Point {",
      "  F x, y;",
      "  Point() : x(0), y(0) {}",
      "  Point(const F& _x, const F& _y) : x(_x), y(_y) {}",
      "",
      "  void swap(Point& other) { using std::swap; swap(x, other.x); swap(y, other.y); }",
      "  template <class F1> explicit operator Point<F1> () const {",
      "    return Point<F1>(static_cast<F1>(x), static_cast<F1>(y)); }",
      "  template <class F1> Point& operator = (const Point<F1>& other) {",
      "    x = other.x; y = other.y; return *this; }",
      "  template <class F1> Point& operator += (const Point<F1>& other) {",
      "    x += other.x; y += other.y; return *this; }",
      "  template <class F1> Point& operator -= (const Point<F1>& other) {",
      "    x -= other.x; y -= other.y; return *this; }",
      "  template <class F1> Point& operator *= (const F1& factor) {",
      "    x *= factor; y *= factor; return *this; }",
      "  template <class F1> Point& operator /= (const F1& factor) {",
      "    x /= factor; y /= factor; return *this; }",
      "};",
      "",
      "template <class F> int read(Point<F>& point) { return read(point.x, point.y) / 2; }",
      "template <class F> int write(const Point<F>& point) { return write(point.x, point.y); }",
      "",
      "template <class F> std::istream& operator >> (std::istream& is, Point<F>& point) {",
      "  return is >> point.x >> point.y; }",
      "template <class F> std::ostream& operator << (std::ostream& os, const Point<F>& point) {",
      "  return os << point.x << ' ' << point.y; }",
      "",
      "template <class F> inline Point<F> makePoint(const F& x, const F& y) { return Point<F>(x, y); }",
      "template <class F> void swap(Point<F>& lhs, Point<F>& rhs) { lhs.swap(rhs); }",
      "",
      "#define FUNC1(name, arg, expr) \\",
      "template <class F> inline auto name(const arg) -> decltype(expr) { return expr; }",
      "#define FUNC2(name, arg1, arg2, expr) \\",
      "template <class F1, class F2> \\",
      "inline auto name(const arg1, const arg2) -> decltype(expr) { return expr; }",
      "#define FUNC3(name, arg1, arg2, arg3, expr) \\",
      "template <class F1, class F2, class F3> \\",
      "inline auto name(const arg1, const arg2, const arg3) -> decltype(expr) { return expr; }",
      "",
      "FUNC1(operator -, Point<F>& point, makePoint(-point.x, -point.y))",
      "FUNC2(operator +, Point<F1>& lhs, Point<F2>& rhs, makePoint(lhs.x + rhs.x, lhs.y + rhs.y))",
      "FUNC2(operator -, Point<F1>& lhs, Point<F2>& rhs, makePoint(lhs.x - rhs.x, lhs.y - rhs.y))",
      "FUNC2(operator *, F1& factor, Point<F2>& rhs, makePoint(factor * rhs.x, factor * rhs.y))",
      "FUNC2(operator *, Point<F1>& lhs, F2& factor, makePoint(lhs.x * factor, lhs.y * factor))",
      "FUNC2(operator /, Point<F1>& lhs, F2& factor, makePoint(lhs.x / factor, lhs.y / factor))",
      "",
      "FUNC2(operator *, Point<F1>& lhs, Point<F2>& rhs, lhs.x * rhs.x + lhs.y * rhs.y)",
      "FUNC2(operator ^, Point<F1>& lhs, Point<F2>& rhs, lhs.x * rhs.y - lhs.y * rhs.x)",
      "",
      "// < 0 if rhs <- lhs counter-clockwise, 0 if collinear, > 0 if clockwise.",
      "FUNC2(ccw, Point<F1>& lhs, Point<F2>& rhs, rhs ^ lhs)",
      "FUNC3(ccw, Point<F1>& lhs, Point<F2>& rhs, Point<F3>& origin, ccw(lhs - origin, rhs - origin))",
      "",
      "FUNC2(operator ==, Point<F1>& lhs, Point<F2>& rhs, lhs.x == rhs.x && lhs.y == rhs.y)",
      "FUNC2(operator !=, Point<F1>& lhs, Point<F2>& rhs, !(lhs == rhs))",
      "",
      "FUNC2(operator <, Point<F1>& lhs, Point<F2>& rhs,",
      "    lhs.y < rhs.y || (lhs.y == rhs.y && lhs.x < rhs.x))",
      "FUNC2(operator >, Point<F1>& lhs, Point<F2>& rhs, rhs < lhs)",
      "FUNC2(operator <=, Point<F1>& lhs, Point<F2>& rhs, !(lhs > rhs))",
      "FUNC2(operator >=, Point<F1>& lhs, Point<F2>& rhs, !(lhs < rhs))",
      "",
      "// Angles and rotations (counter-clockwise).",
      "FUNC1(angle, Point<F>& point, atan2(point.y, point.x))",
      "FUNC2(angle, Point<F1>& lhs, Point<F2>& rhs, atan2(lhs ^ rhs, lhs * rhs))",
      "FUNC3(angle, Point<F1>& lhs, Point<F2>& rhs, Point<F3>& origin,",
      "      angle(lhs - origin, rhs - origin))",
      "FUNC3(rotate, Point<F1>& point, F2& angleSin, F3& angleCos,",
      "      makePoint(angleCos * point.x - angleSin * point.y,",
      "                angleSin * point.x + angleCos * point.y))",
      "FUNC2(rotate, Point<F1>& point, F2& angle, rotate(point, sin(angle), cos(angle)))",
      "FUNC3(rotate, Point<F1>& point, F2& angle, Point<F3>& origin,",
      "      origin + rotate(point - origin, angle))",
      "FUNC1(perp, Point<F>& point, makePoint(-point.y, point.x))",
      "",
      "// Distances.",
      "FUNC1(abs, Point<F>& point, point * point)",
      "FUNC1(norm, Point<F>& point, sqrt(abs(point)))",
      "FUNC2(dist, Point<F1>& lhs, Point<F2>& rhs, norm(lhs - rhs))",
      "FUNC2(dist2, Point<F1>& lhs, Point<F2>& rhs, abs(lhs - rhs))",
      "FUNC2(bisector, Point<F1>& lhs, Point<F2>& rhs, lhs * norm(rhs) + rhs * norm(lhs))",
      "",
      "#undef FUNC1",
      "#undef FUNC2",
      "#undef FUNC3"
    ],
    "description": "point"
  },
  "dfstree": {
    "prefix": "dfstree",
    "body": [
      "struct DFSTree {",
      "  int n;",
      "  std::vector<std::vector<int>> adj;",
      "  std::vector<int> st, lo;",
      "",
      "  bool solved;",
      "",
      "  struct Edge {",
      "    int u, v;",
      "",
      "    inline int other(int x) const {return x ^ u ^ v; }",
      "  };",
      "",
      "  std::vector<Edge> edges;",
      "  std::vector<int> pa;",
      "",
      "  std::vector<std::vector<int>> belongv;",
      "  int cnt_block = 0;",
      "",
      "  void dfs(int u, int pid, std::stack<int>& stk, int& ti) {",
      "    stk.push(u);",
      "    st[u] = lo[u] = ti++;",
      "    for (auto eid : adj[u]) {",
      "      if (eid == pid) continue;",
      "      int v = edges[eid].other(u);",
      "      if (st[v] == -1) {",
      "        pa[v] = eid;",
      "        dfs(v, eid, stk, ti);",
      "        lo[u] = std::min(lo[u], lo[v]);",
      "        if (lo[v] >= st[u]) {",
      "          belongv[u].push_back(cnt_block);",
      "          int lst = u;",
      "          while (lst != v) {",
      "            lst = stk.top();",
      "            belongv[lst].push_back(cnt_block);",
      "            stk.pop();",
      "          }",
      "          cnt_block++;",
      "        }",
      "      } else {",
      "        lo[u] = std::min(lo[u], st[v]);",
      "      }",
      "    }",
      "  }",
      "",
      "  DFSTree() {}",
      "  DFSTree(int _n) { init(_n); }",
      "",
      "  void init(int _n) {",
      "    n = _n;",
      "    adj.assign(n, {});",
      "    st.assign(n, -1);",
      "    lo.assign(n, -1);",
      "    pa.assign(n, -1);",
      "    belongv.assign(n, {});",
      "    solved = 0;",
      "  }",
      "",
      "  void add_edge(int u, int v) {",
      "    int id = edges.size();",
      "    adj[u].emplace_back(id);",
      "    adj[v].emplace_back(id);",
      "    edges.push_back({u, v});",
      "  }",
      "",
      "  std::vector<int> is_bridge;",
      "",
      "  void solve() {",
      "    is_bridge.assign(edges.size(), 0);",
      "    int ti = 0;",
      "    std::stack<int> stk;",
      "    for (int i = 0; i < n; i++) {",
      "      if (st[i] == -1) {",
      "        dfs(i, -1, stk, ti);",
      "      }",
      "",
      "      if (pa[i] != -1 && lo[i] >= st[i]) {",
      "        is_bridge[pa[i]] = 1;",
      "      }",
      "    }",
      "    solved = 1;",
      "  }",
      "",
      "  std::vector<int> bridges;",
      "  std::vector<std::vector<int>> ecomps;",
      "  std::vector<int> belonge;",
      "",
      "  std::vector<std::pair<int, int>> solve_two_edge_connectivity() {",
      "    assert(solved);",
      "    std::vector<int> e(n, -1);",
      "    auto find = [&](auto self, int u) -> int {",
      "      return e[u] < 0 ? u : e[u] = self(self, e[u]);",
      "    };",
      "    for (int i = 0; i < (int) edges.size(); i++) {",
      "      auto [u, v] = edges[i];",
      "      if (!is_bridge[i]) {",
      "        int pv = find(find, v), pu = find(find, u);",
      "        if (pu != pv) {",
      "          if (e[pu] > e[pv]) std::swap(pu, pv);",
      "          e[pu] += e[pv];",
      "          e[pv] = pu;",
      "        }",
      "      } else {",
      "        bridges.push_back(i);",
      "      }",
      "    }",
      "",
      "    std::vector<std::vector<int>> comps(n);",
      "    for (int i = 0; i < n; i++) {",
      "      comps[find(find, i)].push_back(i);",
      "    }",
      "",
      "    belonge.assign(n, -1);",
      "    for (int i = 0; i < n; i++) {",
      "      if (comps[i].empty()) continue;",
      "      for (int j : comps[i]) {",
      "        belonge[j] = ecomps.size();",
      "      }",
      "      ecomps.emplace_back(comps[i]);",
      "    }",
      "",
      "",
      "    std::vector<std::pair<int, int>> gg;",
      "    for (int i : bridges) {",
      "      auto [u, v] = edges[i];",
      "      gg.emplace_back(belonge[u], belonge[v]);",
      "    }",
      "",
      "    return gg;",
      "  }",
      "",
      "  std::vector<std::pair<int, int>> solve_biconnected_components() {",
      "    assert(solved);",
      "    std::vector<std::pair<int, int>> gg;",
      "    for (int i = 0; i < n; i++) {",
      "      for (int v : belongv[i]) {",
      "        gg.emplace_back(i, n + v);",
      "      }",
      "    }",
      "    return gg;",
      "  }",
      "",
      "  std::vector<int> get_articulation_points() {",
      "    std::vector<int> res;",
      "    for (int i = 0; i < n; i++) {",
      "      if (belongv[i].size() > 1) {",
      "        res.push_back(i);",
      "      }",
      "    }",
      "    return res;",
      "  }",
      "};"
    ],
    "description": "dfstree"
  },
  "hld": {
    "prefix": "hld",
    "body": [
      "struct HeavyLightDecomposition {",
      "  int n;",
      "  std::vector<int> sz, pa, dep, who, st, en, top;",
      "  std::vector<std::vector<int>> adj;",
      "",
      "  HeavyLightDecomposition(int _n) { init(_n); }",
      "",
      "  void init(int _n) {",
      "    n = _n;",
      "    sz.assign(n, 1);",
      "    pa.assign(n, 0);",
      "    dep.assign(n, 0);",
      "    who.assign(n, 0);",
      "    st.assign(n, 0);",
      "    en.assign(n, 0);",
      "    top.assign(n, 0);",
      "    adj.assign(n, {});",
      "  }",
      "",
      "  void add_edge(int u, int v) {",
      "    adj[u].push_back(v);",
      "    adj[v].push_back(u);",
      "  }",
      "",
      "  void dfs_size(int u) {",
      "    for (int& v : adj[u]) {",
      "      adj[v].erase(std::find(adj[v].begin(), adj[v].end(), u));",
      "      pa[v] = u;",
      "      dep[v] = dep[u] + 1;",
      "      dfs_size(v);",
      "      sz[u] += sz[v];",
      "      if (sz[v] > sz[adj[u][0]]) std::swap(v, adj[u][0]);",
      "    }",
      "  }",
      "",
      "  void dfs_hld(int u, int& ti) {",
      "    who[ti] = u;",
      "    st[u] = ti++;",
      "    for (int v : adj[u]) {",
      "      top[v] = adj[u][0] == v ? top[u] : v;",
      "      dfs_hld(v, ti);",
      "    }",
      "    en[u] = ti;",
      "  }",
      "",
      "  void work(int root = 0) {",
      "    dfs_size(root);",
      "    int ti = 0;",
      "    dfs_hld(root, ti);",
      "  }",
      "",
      "  int lift(int u, int d) {",
      "    d = dep[u] - std::min(d, dep[u]);",
      "    while (dep[top[u]] > d) {",
      "      u = pa[top[u]];",
      "    }",
      "    return who[st[top[u]] + d - dep[top[u]]];",
      "  }",
      "",
      "  int lca(int u, int v) {",
      "    while (top[u] != top[v]) {",
      "      if (dep[top[v]] < dep[top[u]]) std::swap(u, v);",
      "      v = pa[top[v]];",
      "    }",
      "    return dep[v] < dep[u] ? v : u;",
      "  }",
      "",
      "  inline int dist(int u, int v) { return dep[u] + dep[v] - 2 * dep[lca(u, v)]; }",
      "",
      "  bool is_ancestor(int p, int u) { return st[p] < st[u] && st[u] < en[p]; }",
      "  bool is_ancestor_allow_same(int p, int u) {",
      "    return st[p] <= st[u] && st[u] < en[p];",
      "  }",
      "",
      "  bool is_same_subtree(int u, int v) {",
      "    return is_ancestor_allow_same(u, v) || is_ancestor_allow_same(v, u);",
      "  }",
      "",
      "  int rooted_parent(int p, int u) {",
      "    if (p == u) return p;",
      "    if (!is_ancestor(u, p)) {",
      "      return pa[u];",
      "    }",
      "    auto it = upper_bound(adj[u].begin(), adj[u].end(), p,",
      "                          [&](int x, int y) { return st[x] < st[y]; }) -",
      "              1;",
      "    return *it;",
      "  }",
      "",
      "  int rooted_size(int p, int u) {",
      "    if (p == u) return n;",
      "    if (!is_ancestor(u, p)) {",
      "      return sz[u];",
      "    }",
      "    return n - sz[rooted_parent(p, u)];",
      "  }",
      "",
      "  int rooted_lca(int a, int b, int c) {",
      "    return lca(a, b) ^ lca(b, c) ^ lca(c, a);",
      "  }",
      "};"
    ],
    "description": "hld"
  },
  "twosat": {
    "prefix": "twosat",
    "body": [
      "struct TwoSat {",
      "  int n;",
      "  std::vector<std::vector<int>> adj;",
      "  std::vector<bool> ans;",
      "",
      "  TwoSat(int _n) : n(_n), adj(2 * n), ans(n) {}",
      "",
      "  /*",
      "  Forcing x to be true -> x or x",
      "  Exactly one must be true -> (x or y) and (not x or not y)",
      "  At least one is true -> x or y",
      "  Both have the same value -> (not x or y) and (x or not y)",
      "  */",
      "  void add_clause(int u, bool f, int v, bool g) {",
      "    adj[2 * u + !f].push_back(2 * v + g);",
      "    adj[2 * v + !g].push_back(2 * u + f);",
      "  }",
      "",
      "  bool solve() {",
      "    std::vector<int> id(2 * n, -1), st(2 * n, -1), lo(2 * n, -1);",
      "    std::vector<int> stk;",
      "    int ti = 0, cnt = 0;",
      "    auto dfs = [&](auto self, int u) -> void {",
      "      stk.push_back(u);",
      "      st[u] = lo[u] = ti++;",
      "      for (auto v : adj[u]) {",
      "        if (st[v] == -1) {",
      "          self(self, v);",
      "          lo[u] = std::min(lo[u], lo[v]);",
      "        } else if (id[v] == -1) {",
      "          lo[u] = std::min(lo[u], st[v]);",
      "        }",
      "      }",
      "      if (st[u] == lo[u]) {",
      "        int v;",
      "        do {",
      "          v = stk.back();",
      "          stk.pop_back();",
      "          id[v] = cnt;",
      "        } while (v != u);",
      "        ++cnt;",
      "      }",
      "    };",
      "",
      "    for (int i = 0; i < 2 * n; ++i)",
      "      if (st[i] == -1) dfs(dfs, i);",
      "    for (int i = 0; i < n; ++i) {",
      "      if (id[2 * i] == id[2 * i + 1]) return false;",
      "      ans[i] = id[2 * i] > id[2 * i + 1];",
      "    }",
      "    return true;",
      "  }",
      "",
      "  std::vector<bool> get_answer() { return ans; }",
      "};"
    ],
    "description": "twosat"
  },
  "fastinput": {
    "prefix": "fastinput",
    "body": [
      "static struct FastInput {",
      "  static constexpr int BUF_SIZE = 1 << 20;",
      "  char buf[BUF_SIZE];",
      "  size_t chars_read = 0;",
      "  size_t buf_pos = 0;",
      "  FILE *in = stdin;",
      "  char cur = 0;",
      "",
      "  inline char get_char() {",
      "    if (buf_pos >= chars_read) {",
      "      chars_read = fread(buf, 1, BUF_SIZE, in);",
      "      buf_pos = 0;",
      "      buf[0] = (chars_read == 0 ? -1 : buf[0]);",
      "    }",
      "    return cur = buf[buf_pos++];",
      "  }",
      "",
      "  inline void tie(int) {}",
      "",
      "  inline explicit operator bool() {",
      "    return cur != -1;",
      "  }",
      "",
      "  inline static bool is_blank(char c) {",
      "    return c <= ' ';",
      "  }",
      "",
      "  inline bool skip_blanks() {",
      "    while (is_blank(cur) && cur != -1) {",
      "      get_char();",
      "    }",
      "    return cur != -1;",
      "  }",
      "",
      "  inline FastInput& operator>>(char& c) {",
      "    skip_blanks();",
      "    c = cur;",
      "    get_char();",
      "    return *this;",
      "  }",
      "",
      "  inline FastInput& operator>>(string& s) {",
      "    if (skip_blanks()) {",
      "      s.clear();",
      "      do {",
      "        s += cur;",
      "      } while (!is_blank(get_char()));",
      "    }",
      "    return *this;",
      "  }",
      "",
      "  template <typename T>",
      "  inline FastInput& read_integer(T& n) {",
      "    // unsafe, doesn't check that characters are actually digits",
      "    n = 0;",
      "    if (skip_blanks()) {",
      "      int sign = +1;",
      "      if (cur == '-') {",
      "        sign = -1;",
      "        get_char();",
      "      }",
      "      do {",
      "        n += n + (n << 3) + cur - '0';",
      "      } while (!is_blank(get_char()));",
      "      n *= sign;",
      "    }",
      "    return *this;",
      "  }",
      "",
      "  template <typename T>",
      "  inline typename enable_if<is_integral<T>::value, FastInput&>::type operator>>(T& n) {",
      "    return read_integer(n);",
      "  }",
      "",
      "  #if !defined(_WIN32) || defined(_WIN64)",
      "  inline FastInput& operator>>(__int128& n) {",
      "    return read_integer(n);",
      "  }",
      "  #endif",
      "",
      "  template <typename T>",
      "  inline typename enable_if<is_floating_point<T>::value, FastInput&>::type operator>>(T& n) {",
      "    // not sure if really fast, for compatibility only",
      "    n = 0;",
      "    if (skip_blanks()) {",
      "      string s;",
      "      (*this) >> s;",
      "      sscanf(s.c_str(), \"%lf\", &n);",
      "    }",
      "    return *this;",
      "  }",
      "} fast_input;",
      "",
      "#define cin fast_input"
    ],
    "description": "fastinput"
  },
  "fastoutput": {
    "prefix": "fastoutput",
    "body": [
      "static struct FastOutput {",
      "  static constexpr int BUF_SIZE = 1 << 20;",
      "  char buf[BUF_SIZE];",
      "  size_t buf_pos = 0;",
      "  static constexpr int TMP_SIZE = 1 << 20;",
      "  char tmp[TMP_SIZE];",
      "  FILE* out = stdout;",
      "",
      "  inline void put_char(char c) {",
      "    buf[buf_pos++] = c;",
      "    if (buf_pos == BUF_SIZE) {",
      "      fwrite(buf, 1, buf_pos, out);",
      "      buf_pos = 0;",
      "    }",
      "  }",
      "",
      "  ~FastOutput() { fwrite(buf, 1, buf_pos, out); }",
      "",
      "  inline FastOutput& operator<<(char c) {",
      "    put_char(c);",
      "    return *this;",
      "  }",
      "",
      "  inline FastOutput& operator<<(const char* s) {",
      "    while (*s) {",
      "      put_char(*s++);",
      "    }",
      "    return *this;",
      "  }",
      "",
      "  inline FastOutput& operator<<(const string& s) {",
      "    for (int i = 0; i < (int) s.size(); i++) {",
      "      put_char(s[i]);",
      "    }",
      "    return *this;",
      "  }",
      "",
      "  template <typename T>",
      "  inline char* integer_to_string(T n) {",
      "    // beware of TMP_SIZE",
      "    char* p = tmp + TMP_SIZE - 1;",
      "    if (n == 0) {",
      "      *--p = '0';",
      "    } else {",
      "      bool is_negative = false;",
      "      if (n < 0) {",
      "        is_negative = true;",
      "        n = -n;",
      "      }",
      "      while (n > 0) {",
      "        *--p = (char) ('0' + n % 10);",
      "        n /= 10;",
      "      }",
      "      if (is_negative) {",
      "        *--p = '-';",
      "      }",
      "    }",
      "    return p;",
      "  }",
      "",
      "  template <typename T>",
      "  inline typename enable_if<is_integral<T>::value, char*>::type stringify(T n) {",
      "    return integer_to_string(n);",
      "  }",
      "",
      "#if !defined(_WIN32) || defined(_WIN64)",
      "  inline char* stringify(__int128 n) { return integer_to_string(n); }",
      "#endif",
      "",
      "  template <typename T>",
      "  inline typename enable_if<is_floating_point<T>::value, char*>::type stringify(",
      "      T n) {",
      "    sprintf(tmp, \"%.17f\", n);",
      "    return tmp;",
      "  }",
      "",
      "  template <typename T>",
      "  inline FastOutput& operator<<(const T& n) {",
      "    auto p = stringify(n);",
      "    for (; *p != 0; p++) {",
      "      put_char(*p);",
      "    }",
      "    return *this;",
      "  }",
      "} fast_output;"
    ],
    "description": "fastoutput"
  },
  "rng": {
    "prefix": "rng",
    "body": [
      "// std::mt19937_64 rng(0); // Fixed seed",
      "std::mt19937_64 rng(std::chrono::high_resolution_clock::now().time_since_epoch().count());",
      "#define uid(a, b) std::uniform_int_distribution<long long>(a, b)(rng)"
    ],
    "description": "rng"
  },
  "extgcd": {
    "prefix": "extgcd",
    "body": [
      "template <typename T>",
      "T extgcd(T a, T b, T &x, T &y) {",
      "  x = 1, y = 0;",
      "  T x1 = 0, y1 = 1, a1 = a, b1 = b;",
      "  while (b1) {",
      "    T q = a1 / b1;",
      "    std::tie(x, x1) = std::make_tuple(x1, x - q * x1);",
      "    std::tie(y, y1) = std::make_tuple(y1, y - q * y1);",
      "    std::tie(a1, b1) = std::make_tuple(b1, a1 - q * b1);",
      "  }",
      "  return a1;",
      "}",
      "",
      "template <typename T>",
      "bool diophantine(T a, T b, T c, T &x, T &y, T &g) {",
      "  if (a == 0 && b == 0) {",
      "    if (c == 0) {",
      "      x = y = g = 0;",
      "      return true;",
      "    }",
      "    return false;",
      "  }",
      "  if (a == 0) {",
      "    if (c % b == 0) {",
      "      x = 0;",
      "      y = c / b;",
      "      g = abs(b);",
      "      return true;",
      "    }",
      "    return false;",
      "  }",
      "  if (b == 0) {",
      "    if (c % a == 0) {",
      "      x = c / a;",
      "      y = 0;",
      "      g = abs(a);",
      "      return true;",
      "    }",
      "    return false;",
      "  }",
      "  g = extgcd(a, b, x, y);",
      "  if (c % g != 0) {",
      "    return false;",
      "  }",
      "  T dx = c / a;",
      "  c -= dx * a;",
      "  T dy = c / b;",
      "  c -= dy * b;",
      "  x = dx + (T)((__int128_t)x * (c / g) % b);",
      "  y = dy + (T)((__int128_t)y * (c / g) % a);",
      "  g = abs(g);",
      "  return true;",
      "  // |x|, |y| <= max(|a|, |b|, |c|) [tested]",
      "}",
      "",
      "bool crt(long long k1, long long m1, long long k2, long long m2, long long &k,",
      "         long long &m) {",
      "  k1 %= m1;",
      "  if (k1 < 0) k1 += m1;",
      "  k2 %= m2;",
      "  if (k2 < 0) k2 += m2;",
      "  long long x, y, g;",
      "  if (!diophantine(m1, -m2, k2 - k1, x, y, g)) {",
      "    return false;",
      "  }",
      "  long long dx = m2 / g;",
      "  long long delta = x / dx - (x % dx < 0);",
      "  k = m1 * (x - dx * delta) + k1;",
      "  m = m1 / g * m2;",
      "  assert(0 <= k && k < m);",
      "  return true;",
      "}",
      "",
      "// for distinct prime modulos",
      "template <typename T>",
      "void crt_garner(const std::vector<int> &p, const std::vector<int> &a, T &res) {",
      "  assert(p.size() == a.size());",
      "  auto inverse = [&](int q, int m) {",
      "    q %= m;",
      "    if (q < 0) q += m;",
      "    int b = m, u = 0, v = 1;",
      "    while (q) {",
      "      int t = b / q;",
      "      b -= t * q;",
      "      std::swap(q, b);",
      "      u -= t * v;",
      "      std::swap(u, v);",
      "    }",
      "    assert(b == 1);",
      "    if (u < 0) u += m;",
      "    return u;",
      "  };",
      "  std::vector<int> x(p.size());",
      "  for (int i = 0; i < (int)p.size(); i++) {",
      "    assert(0 <= a[i] && a[i] < p[i]);",
      "    x[i] = a[i];",
      "    for (int j = 0; j < i; j++) {",
      "      x[i] = (int)((long long)(x[i] - x[j]) * inverse(p[j], p[i]) % p[i]);",
      "      if (x[i] < 0) x[i] += p[i];",
      "    }",
      "  }",
      "  res = 0;",
      "  for (int i = (int)p.size() - 1; i >= 0; i--) {",
      "    res = res * p[i] + x[i];",
      "  }",
      "}"
    ],
    "description": "extgcd"
  },
  "fft": {
    "prefix": "fft",
    "body": [
      "namespace fft {",
      "",
      "typedef double dbl;",
      "",
      "struct num {",
      "  dbl x, y;",
      "  num() { x = y = 0; }",
      "  num(dbl x_, dbl y_) : x(x_), y(y_) {}",
      "};",
      "",
      "inline num operator+(num a, num b) { return num(a.x + b.x, a.y + b.y); }",
      "inline num operator-(num a, num b) { return num(a.x - b.x, a.y - b.y); }",
      "inline num operator*(num a, num b) { return num(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }",
      "inline num conj(num a) { return num(a.x, -a.y); }",
      "",
      "int base = 1;",
      "std::vector<num> roots = {{0, 0}, {1, 0}};",
      "std::vector<int> rev = {0, 1};",
      "",
      "const dbl PI = static_cast<dbl>(acosl(-1.0));",
      "",
      "void ensure_base(int nbase) {",
      "  if (nbase <= base) {",
      "    return;",
      "  }",
      "  rev.resize(1 << nbase);",
      "  for (int i = 0; i < (1 << nbase); i++) {",
      "    rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));",
      "  }",
      "  roots.resize(1 << nbase);",
      "  while (base < nbase) {",
      "    dbl angle = 2 * PI / (1 << (base + 1));",
      "//      num z(cos(angle), sin(angle));",
      "    for (int i = 1 << (base - 1); i < (1 << base); i++) {",
      "      roots[i << 1] = roots[i];",
      "//        roots[(i << 1) + 1] = roots[i] * z;",
      "      dbl angle_i = angle * (2 * i + 1 - (1 << base));",
      "      roots[(i << 1) + 1] = num(cos(angle_i), sin(angle_i));",
      "    }",
      "    base++;",
      "  }",
      "}",
      "",
      "void fft(std::vector<num>& a, int n = -1) {",
      "  if (n == -1) {",
      "    n = (int) a.size();",
      "  }",
      "  assert((n & (n - 1)) == 0);",
      "  int zeros = __builtin_ctz(n);",
      "  ensure_base(zeros);",
      "  int shift = base - zeros;",
      "  for (int i = 0; i < n; i++) {",
      "    if (i < (rev[i] >> shift)) {",
      "      std::swap(a[i], a[rev[i] >> shift]);",
      "    }",
      "  }",
      "  for (int k = 1; k < n; k <<= 1) {",
      "    for (int i = 0; i < n; i += 2 * k) {",
      "      for (int j = 0; j < k; j++) {",
      "        num z = a[i + j + k] * roots[j + k];",
      "        a[i + j + k] = a[i + j] - z;",
      "        a[i + j] = a[i + j] + z;",
      "      }",
      "    }",
      "  }",
      "}",
      "",
      "std::vector<num> fa, fb;",
      "",
      "std::vector<int64_t> square(const std::vector<int>& a) {",
      "  if (a.empty()) {",
      "    return {};",
      "  }",
      "  int need = (int) a.size() + (int) a.size() - 1;",
      "  int nbase = 1;",
      "  while ((1 << nbase) < need) nbase++;",
      "  ensure_base(nbase);",
      "  int sz = 1 << nbase;",
      "  if ((sz >> 1) > (int) fa.size()) {",
      "    fa.resize(sz >> 1);",
      "  }",
      "  for (int i = 0; i < (sz >> 1); i++) {",
      "    int x = (2 * i < (int) a.size() ? a[2 * i] : 0);",
      "    int y = (2 * i + 1 < (int) a.size() ? a[2 * i + 1] : 0);",
      "    fa[i] = num(x, y);",
      "  }",
      "  fft(fa, sz >> 1);",
      "  num r(1.0 / (sz >> 1), 0.0);",
      "  for (int i = 0; i <= (sz >> 2); i++) {",
      "    int j = ((sz >> 1) - i) & ((sz >> 1) - 1);",
      "    num fe = (fa[i] + conj(fa[j])) * num(0.5, 0);",
      "    num fo = (fa[i] - conj(fa[j])) * num(0, -0.5);",
      "    num aux = fe * fe + fo * fo * roots[(sz >> 1) + i] * roots[(sz >> 1) + i];",
      "    num tmp = fe * fo;",
      "    fa[i] = r * (conj(aux) + num(0, 2) * conj(tmp));",
      "    fa[j] = r * (aux + num(0, 2) * tmp);",
      "  }",
      "  fft(fa, sz >> 1);",
      "  std::vector<int64_t> res(need);",
      "  for (int i = 0; i < need; i++) {",
      "    res[i] = llround(i % 2 == 0 ? fa[i >> 1].x : fa[i >> 1].y);",
      "  }",
      "  return res;",
      "}",
      "",
      "std::vector<int64_t> multiply(const std::vector<int>& a, const std::vector<int>& b) {",
      "  if (a.empty() || b.empty()) {",
      "    return {};",
      "  }",
      "  if (a == b) {",
      "    return square(a);",
      "  }",
      "  int need = (int) a.size() + (int) b.size() - 1;",
      "  int nbase = 1;",
      "  while ((1 << nbase) < need) nbase++;",
      "  ensure_base(nbase);",
      "  int sz = 1 << nbase;",
      "  if (sz > (int) fa.size()) {",
      "    fa.resize(sz);",
      "  }",
      "  for (int i = 0; i < sz; i++) {",
      "    int x = (i < (int) a.size() ? a[i] : 0);",
      "    int y = (i < (int) b.size() ? b[i] : 0);",
      "    fa[i] = num(x, y);",
      "  }",
      "  fft(fa, sz);",
      "  num r(0, -0.25 / (sz >> 1));",
      "  for (int i = 0; i <= (sz >> 1); i++) {",
      "    int j = (sz - i) & (sz - 1);",
      "    num z = (fa[j] * fa[j] - conj(fa[i] * fa[i])) * r;",
      "    fa[j] = (fa[i] * fa[i] - conj(fa[j] * fa[j])) * r;",
      "    fa[i] = z;",
      "  }",
      "  for (int i = 0; i < (sz >> 1); i++) {",
      "    num A0 = (fa[i] + fa[i + (sz >> 1)]) * num(0.5, 0);",
      "    num A1 = (fa[i] - fa[i + (sz >> 1)]) * num(0.5, 0) * roots[(sz >> 1) + i];",
      "    fa[i] = A0 + A1 * num(0, 1);",
      "  }",
      "  fft(fa, sz >> 1);",
      "  std::vector<int64_t> res(need);",
      "  for (int i = 0; i < need; i++) {",
      "    res[i] = llround(i % 2 == 0 ? fa[i >> 1].x : fa[i >> 1].y);",
      "  }",
      "  return res;",
      "}",
      "",
      "std::vector<int> multiply_mod(const std::vector<int>& a, const std::vector<int>& b, int m) {",
      "  if (a.empty() || b.empty()) {",
      "    return {};",
      "  }",
      "  int eq = (a.size() == b.size() && a == b);",
      "  int need = (int) a.size() + (int) b.size() - 1;",
      "  int nbase = 0;",
      "  while ((1 << nbase) < need) nbase++;",
      "  ensure_base(nbase);",
      "  int sz = 1 << nbase;",
      "  if (sz > (int) fa.size()) {",
      "    fa.resize(sz);",
      "  }",
      "  for (int i = 0; i < (int) a.size(); i++) {",
      "    int x = (a[i] % m + m) % m;",
      "    fa[i] = num(x & ((1 << 15) - 1), x >> 15);",
      "  }",
      "  fill(fa.begin() + a.size(), fa.begin() + sz, num {0, 0});",
      "  fft(fa, sz);",
      "  if (sz > (int) fb.size()) {",
      "    fb.resize(sz);",
      "  }",
      "  if (eq) {",
      "    copy(fa.begin(), fa.begin() + sz, fb.begin());",
      "  } else {",
      "    for (int i = 0; i < (int) b.size(); i++) {",
      "      int x = (b[i] % m + m) % m;",
      "      fb[i] = num(x & ((1 << 15) - 1), x >> 15);",
      "    }",
      "    fill(fb.begin() + b.size(), fb.begin() + sz, num {0, 0});",
      "    fft(fb, sz);",
      "  }",
      "  dbl ratio = 0.25 / sz;",
      "  num r2(0, -1);",
      "  num r3(ratio, 0);",
      "  num r4(0, -ratio);",
      "  num r5(0, 1);",
      "  for (int i = 0; i <= (sz >> 1); i++) {",
      "    int j = (sz - i) & (sz - 1);",
      "    num a1 = (fa[i] + conj(fa[j]));",
      "    num a2 = (fa[i] - conj(fa[j])) * r2;",
      "    num b1 = (fb[i] + conj(fb[j])) * r3;",
      "    num b2 = (fb[i] - conj(fb[j])) * r4;",
      "    if (i != j) {",
      "      num c1 = (fa[j] + conj(fa[i]));",
      "      num c2 = (fa[j] - conj(fa[i])) * r2;",
      "      num d1 = (fb[j] + conj(fb[i])) * r3;",
      "      num d2 = (fb[j] - conj(fb[i])) * r4;",
      "      fa[i] = c1 * d1 + c2 * d2 * r5;",
      "      fb[i] = c1 * d2 + c2 * d1;",
      "    }",
      "    fa[j] = a1 * b1 + a2 * b2 * r5;",
      "    fb[j] = a1 * b2 + a2 * b1;",
      "  }",
      "  fft(fa, sz);",
      "  fft(fb, sz);",
      "  std::vector<int> res(need);",
      "  for (int i = 0; i < need; i++) {",
      "    int64_t aa = llround(fa[i].x);",
      "    int64_t bb = llround(fb[i].x);",
      "    int64_t cc = llround(fa[i].y);",
      "    res[i] = static_cast<int>((aa + ((bb % m) << 15) + ((cc % m) << 30)) % m);",
      "  }",
      "  return res;",
      "}",
      "",
      "}  // namespace fft"
    ],
    "description": "fft"
  },
  "aho": {
    "prefix": "aho",
    "body": [
      "template <size_t X = 26, char margin = 'a'>",
      "struct Trie {",
      "  struct Node {",
      "    std::array<int, X> nxt;",
      "    std::vector<int> idxs;",
      "    int idx;",
      "    char key;",
      "    Node(char c) : idx(-1), key(c) { fill(nxt.begin(), nxt.end(), -1); }",
      "  };",
      "",
      "  std::vector<Node> st;",
      "",
      "  Trie(char c = '$') { st.emplace_back(c); }",
      "",
      "  inline int &next(int i, int j) { return st[i].nxt[j]; }",
      "",
      "  void add(const std::string &s, int x) {",
      "    int pos = 0;",
      "    for (int i = 0; i < (int)s.size(); i++) {",
      "      int k = s[i] - margin;",
      "      if (~next(pos, k)) {",
      "        pos = next(pos, k);",
      "        continue;",
      "      }",
      "      int npos = st.size();",
      "      next(pos, k) = npos;",
      "      st.emplace_back(s[i]);",
      "      pos = npos;",
      "    }",
      "    st[pos].idx = x;",
      "    st[pos].idxs.emplace_back(x);",
      "  }",
      "",
      "  int find(const std::string &s) {",
      "    int pos = 0;",
      "    for (int i = 0; i < (int)s.size(); i++) {",
      "      int k = s[i] - margin;",
      "      if (next(pos, k) < 0) return -1;",
      "      pos = next(pos, k);",
      "    }",
      "    return pos;",
      "  }",
      "",
      "  int move(int pos, char c) {",
      "    assert(pos < (int)st.size());",
      "    return pos < 0 ? -1 : next(pos, c - margin);",
      "  }",
      "",
      "  int size() const { return st.size(); }",
      "",
      "  int idx(int pos) { return pos < 0 ? -1 : st[pos].idx; }",
      "",
      "  std::vector<int> idxs(int pos) { return pos < 0 ? std::vector<int>() : st[pos].idxs; }",
      "};",
      "",
      "template <size_t X = 26, char margin = 'a'>",
      "struct AhoCorasick : Trie<X + 1, margin> {",
      "  using TRIE = Trie<X + 1, margin>;",
      "  using TRIE::next;",
      "  using TRIE::st;",
      "  using TRIE::TRIE;",
      "  std::vector<int> cnt;",
      "",
      "  void build(int heavy = true) {",
      "    int n = st.size();",
      "    cnt.resize(n);",
      "    for (int i = 0; i < n; i++) {",
      "      if (heavy) sort(st[i].idxs.begin(), st[i].idxs.end());",
      "      cnt[i] = st[i].idxs.size();",
      "    }",
      "",
      "    std::queue<int> que;",
      "    for (int i = 0; i < (int)X; i++) {",
      "      if (~next(0, i)) {",
      "        next(next(0, i), X) = 0;",
      "        que.emplace(next(0, i));",
      "      } else {",
      "        next(0, i) = 0;",
      "      }",
      "    }",
      "",
      "    while (!que.empty()) {",
      "      auto &x = st[que.front()];",
      "      int fail = x.nxt[X];",
      "",
      "      cnt[que.front()] += cnt[fail];",
      "      que.pop();",
      "",
      "      for (int i = 0; i < (int)X; i++) {",
      "        int &nx = x.nxt[i];",
      "        if (nx < 0) {",
      "          nx = next(fail, i);",
      "          continue;",
      "        }",
      "        que.emplace(nx);",
      "        next(nx, X) = next(fail, i);",
      "        if (heavy) {",
      "          auto &idx = st[nx].idxs;",
      "          auto &idy = st[next(fail, i)].idxs;",
      "          std::vector<int> idz;",
      "          set_union(idx.begin(), idx.end(), idy.begin(), idy.end(),",
      "                    back_inserter(idz));",
      "          idx = idz;",
      "        }",
      "      }",
      "    }",
      "  }",
      "",
      "  std::vector<int> match(std::string s, int heavy = true) {",
      "    std::vector<int> res(heavy ? TRIE::size() : 1);",
      "    int pos = 0;",
      "    for (auto &c : s) {",
      "      pos = next(pos, c - margin);",
      "      if (heavy)",
      "        for (auto &x : st[pos].idxs) res[x]++;",
      "      else",
      "        res[0] += cnt[pos];",
      "    }",
      "    return res;",
      "  }",
      "",
      "  int count(int pos) { return cnt[pos]; }",
      "};"
    ],
    "description": "aho"
  },
  "hash": {
    "prefix": "hash",
    "body": [
      "#include <bits/stdc++.h>",
      "",
      "namespace hash {",
      "using u64 = uint64_t;",
      "using u32 = uint32_t;",
      "constexpr int kSeed = -1;  // change this to fixed seed for predictable base",
      "constexpr u64 kAlpha = 1000000007;  // the value is from 0 -> kAlphabet - 1",
      "constexpr u64 kMod = (1ULL << 61) - 1;",
      "static_assert(kMod - kAlpha > 2);",
      "// randomly getting an odd base from kAlpha + 1 -> kMod - 1",
      "u64 get_random_base(u64 not_this = -1) {",
      "  std::mt19937_64 h_rng(",
      "      kSeed == -1",
      "          ? std::chrono::high_resolution_clock::now().time_since_epoch().count()",
      "          : kSeed);",
      "  auto rd = std::uniform_int_distribution<u64>(kAlpha + 2, kMod - 1);",
      "  u64 base = rd(h_rng);",
      "  base -= base % 2 == 0;",
      "  while (base == not_this) {",
      "    base = rd(h_rng);",
      "    base -= base % 2 == 0;",
      "  }",
      "  return base;",
      "}",
      "u64 mul(u64 a, u64 b) {",
      "  u64 l1 = (u32)a, h1 = a >> 32, l2 = (u32)b, h2 = b >> 32;",
      "  u64 l = l1 * l2, m = l1 * h2 + l2 * h1, h = h1 * h2;",
      "  u64 ret = (l & kMod) + (l >> 61) + (h << 3) + (m >> 29) + (m << 35 >> 3) + 1;",
      "  ret = (ret & kMod) + (ret >> 61);",
      "  ret = (ret & kMod) + (ret >> 61);",
      "  return ret - 1;",
      "}",
      "u64 add(u64 a, u64 b) { return a += b, a -= (a >= kMod) * kMod; }",
      "u64 sub(u64 a, u64 b) { return a + (a < b) * kMod - b; }",
      "u64 p = get_random_base(), q = get_random_base(p);",
      "std::vector<u64> pp(1, 1), qq(1, 1);",
      "void ensure_pp_size(int size) {",
      "  while ((int)pp.size() < size) pp.emplace_back(mul(pp.back(), p));",
      "}",
      "void ensure_qq_size(int size) {",
      "  while ((int)qq.size() < size) qq.emplace_back(mul(qq.back(), q));",
      "}",
      "struct FwdHash {",
      "  std::vector<u64> hf;",
      "  FwdHash() = default;",
      "  template <typename String>",
      "  FwdHash(const String& s) : hf(s.size() + 1) {",
      "    ensure_pp_size(s.size() + 1);",
      "    for (int i = 0; i < (int)s.size(); i++) {",
      "      hf[i + 1] = add(mul(hf[i], p), s[i] + 1);",
      "    }",
      "  }",
      "  int size() const { return hf.size() - 1; }",
      "  // NOTE: [l, r)",
      "  u64 get_fwd(int l, int r) const { return sub(hf[r], mul(hf[l], pp[r - l])); }",
      "  int operator[](int index) const { return get_fwd(index, index + 1) - 1; }",
      "};",
      "struct FBHash : FwdHash {",
      "  std::vector<u64> hb;",
      "  FBHash() = default;",
      "  template <typename String>",
      "  FBHash(const String& s) : FwdHash(s), hb(s.size() + 1) {",
      "    for (int i = s.size() - 1; i >= 0; i--) {",
      "      hb[i] = add(mul(hb[i + 1], p), s[i] + 1);",
      "    }",
      "  }",
      "  // NOTE: [l, r)",
      "  u64 get_bwd(int l, int r) const { return sub(hb[l], mul(hb[r], pp[r - l])); }",
      "};",
      "struct Hash2D {",
      "  std::vector<std::vector<u64>> h;",
      "  Hash2D() = default;",
      "  template <typename String2D>",
      "  Hash2D(const String2D& s)",
      "      : h(s.size() + 1, std::vector<u64>(s[0].size() + 1)) {",
      "    int n = s.size();",
      "    int m = s[0].size();",
      "    ensure_pp_size(n + 1);",
      "    ensure_qq_size(m + 1);",
      "    for (int i = 0; i < n; i++) {",
      "      for (int j = 0; j < m; j++) {",
      "        h[i + 1][j + 1] = add(mul(h[i + 1][j], q), s[i][j] + 1);",
      "      }",
      "    }",
      "    for (int i = 1; i <= n; i++) {",
      "      for (int j = 1; j <= m; j++) {",
      "        h[i][j] = add(mul(h[i - 1][j], p), h[i][j]);",
      "      }",
      "    }",
      "  }",
      "  // NOTE: [x, u) * [y, v)",
      "  u64 get(int x, int y, int u, int v) {",
      "    auto res = sub(h[u][v], mul(h[x][v], pp[u - x]));",
      "    res = sub(res, mul(h[u][y], qq[v - y]));",
      "    return add(res, mul(mul(h[x][y], pp[u - x]), qq[v - y]));",
      "  }",
      "};",
      "// NOTE: [l1, h1.size()) and [l2, h2.size())",
      "int longest_common_prefix(const FwdHash& h1, const FwdHash& h2, int l1,",
      "                          int l2) {",
      "  int lb = 0, rb = std::min(h1.size() - l1, h2.size() - l2) + 1;",
      "  while (lb < rb - 1) {",
      "    int mb = (lb + rb) / 2;",
      "    if (h1.get_fwd(l1, l1 + mb) == h2.get_fwd(l2, l2 + mb)) {",
      "      lb = mb;",
      "    } else {",
      "      rb = mb;",
      "    }",
      "  }",
      "  return lb;",
      "}",
      "// NOTE: [0, r1) and [0, r2)",
      "int longest_common_suffix(const FwdHash& h1, const FwdHash& h2, int r1,",
      "                          int r2) {",
      "  int lb = 0, rb = std::min(r1, r2) + 1;",
      "  while (lb < rb - 1) {",
      "    int mb = (lb + rb) / 2;",
      "    if (h1.get_fwd(r1 - mb, r1) == h2.get_fwd(r2 - mb, r2)) {",
      "      lb = mb;",
      "    } else {",
      "      rb = mb;",
      "    }",
      "  }",
      "  return lb;",
      "}",
      "// NOTE: [l1, r1) and [l2, r2)",
      "bool is_smaller(const FwdHash& h1, const FwdHash& h2, int l1, int r1, int l2,",
      "                int r2) {",
      "  int lcp = longest_common_prefix(h1, h2, l1, l2);",
      "  int len1 = r1 - l1;",
      "  int len2 = r2 - l2;",
      "  int min_len = std::min(len1, len2);",
      "  return lcp >= min_len ? len1 < len2 : h1[l1 + lcp] < h2[l2 + lcp];",
      "}",
      "}  // namespace hash",
      "",
      "using hash::FBHash;",
      "using hash::FwdHash;",
      "using hash::Hash2D;"
    ],
    "description": "hash"
  },
  "manacher": {
    "prefix": "manacher",
    "body": [
      "",
      "template <typename Container>",
      "std::vector<int> manacher(const Container& S) {",
      "  std::vector<int> res(S.size());",
      "  int i = 0, j = 0;",
      "  while (i < int(S.size())) {",
      "    while (i - j >= 0 and i + j < int(S.size()) and S[i - j] == S[i + j]) j++;",
      "    res[i] = j;",
      "    int k = 1;",
      "    while (i - k >= 0 and i + k < int(S.size()) and k + res[i - k] < j)",
      "      res[i + k] = res[i - k], k++;",
      "    i += k, j -= k;",
      "  }",
      "  return res;",
      "}",
      "",
      "template <typename Container>",
      "std::vector<std::pair<int, int>> enumerate_palindromes(const Container& vec) {",
      "  using T = typename Container::value_type;",
      "  std::vector<T> v;",
      "  const int N = vec.size();",
      "  for (int i = 0; i < N - 1; i++) {",
      "    v.push_back(vec[i]);",
      "    v.push_back(-1);",
      "  }",
      "  v.push_back(vec.back());",
      "  const auto man = manacher(v);",
      "  std::vector<std::pair<int, int>> ret;",
      "  for (int i = 0; i < N * 2 - 1; i++) {",
      "    if (i & 1) {",
      "      int w = man[i] / 2;",
      "      ret.emplace_back((i + 1) / 2 - w, (i + 1) / 2 + w);",
      "    } else {",
      "      int w = (man[i] - 1) / 2;",
      "      ret.emplace_back(i / 2 - w, i / 2 + w + 1);",
      "    }",
      "  }",
      "  return ret;",
      "}",
      "",
      "// ret[r] : s[l, r] smallest l which is a palindrome",
      "template <typename Container>",
      "std::vector<int> enumerate_leftmost_palindromes(const Container& vec) {",
      "  std::vector<int> v(vec.size(), 1);",
      "  for (auto& [l, r] : enumerate_palindromes(vec)) {",
      "    v[r - 1] = std::max(v[r - 1], r - l);",
      "  }",
      "  for (int i = (int)vec.size() - 2; i >= 0; i--) v[i] = std::max(v[i], v[i + 1] - 2);",
      "  std::vector<int> ret(vec.size());",
      "  for (int i = 0; i < (int)vec.size(); i++) ret[i] = i + 1 - v[i];",
      "  return ret;",
      "}",
      "",
      "signed main() {",
      "  std::ios::sync_with_stdio(false);",
      "  std::cin.tie(nullptr);",
      "",
      "}"
    ],
    "description": "manacher"
  },
  "suffarr": {
    "prefix": "suffarr",
    "body": [
      "namespace suffarr {",
      "std::vector<int> suffix_array_induced_sort(const std::vector<int> &s, int upper) {",
      "  int n = int(s.size());",
      "  if (n == 0) return {};",
      "  if (n == 1) return {0};",
      "  if (n == 2) {",
      "    if (s[0] < s[1]) {",
      "      return {0, 1};",
      "    } else {",
      "      return {1, 0};",
      "    }",
      "  }",
      "",
      "  std::vector<int> sa(n);",
      "  std::vector<bool> ls(n);",
      "  for (int i = n - 2; i >= 0; i--) {",
      "    ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);",
      "  }",
      "  std::vector<int> sum_l(upper + 1), sum_s(upper + 1);",
      "  for (int i = 0; i < n; i++) {",
      "    if (!ls[i]) {",
      "      sum_s[s[i]]++;",
      "    } else {",
      "      sum_l[s[i] + 1]++;",
      "    }",
      "  }",
      "  for (int i = 0; i <= upper; i++) {",
      "    sum_s[i] += sum_l[i];",
      "    if (i < upper) sum_l[i + 1] += sum_s[i];",
      "  }",
      "",
      "  auto induce = [&](const std::vector<int> &lms) {",
      "    std::fill(sa.begin(), sa.end(), -1);",
      "    std::vector<int> buf(upper + 1);",
      "    std::copy(sum_s.begin(), sum_s.end(), buf.begin());",
      "    for (auto d : lms) {",
      "      if (d == n) continue;",
      "      sa[buf[s[d]]++] = d;",
      "    }",
      "    std::copy(sum_l.begin(), sum_l.end(), buf.begin());",
      "    sa[buf[s[n - 1]]++] = n - 1;",
      "    for (int i = 0; i < n; i++) {",
      "      int v = sa[i];",
      "      if (v >= 1 && !ls[v - 1]) {",
      "        sa[buf[s[v - 1]]++] = v - 1;",
      "      }",
      "    }",
      "    std::copy(sum_l.begin(), sum_l.end(), buf.begin());",
      "    for (int i = n - 1; i >= 0; i--) {",
      "      int v = sa[i];",
      "      if (v >= 1 && ls[v - 1]) {",
      "        sa[--buf[s[v - 1] + 1]] = v - 1;",
      "      }",
      "    }",
      "  };",
      "",
      "  std::vector<int> lms_map(n + 1, -1);",
      "  int m = 0;",
      "  for (int i = 1; i < n; i++) {",
      "    if (!ls[i - 1] && ls[i]) {",
      "      lms_map[i] = m++;",
      "    }",
      "  }",
      "  std::vector<int> lms;",
      "  lms.reserve(m);",
      "  for (int i = 1; i < n; i++) {",
      "    if (!ls[i - 1] && ls[i]) {",
      "      lms.push_back(i);",
      "    }",
      "  }",
      "",
      "  induce(lms);",
      "",
      "  if (m) {",
      "    std::vector<int> sorted_lms;",
      "    sorted_lms.reserve(m);",
      "    for (int v : sa) {",
      "      if (lms_map[v] != -1) sorted_lms.push_back(v);",
      "    }",
      "    std::vector<int> rec_s(m);",
      "    int rec_upper = 0;",
      "    rec_s[lms_map[sorted_lms[0]]] = 0;",
      "    for (int i = 1; i < m; i++) {",
      "      int l = sorted_lms[i - 1], r = sorted_lms[i];",
      "      int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;",
      "      int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;",
      "      bool same = true;",
      "      if (end_l - l != end_r - r) {",
      "        same = false;",
      "      } else {",
      "        while (l < end_l) {",
      "          if (s[l] != s[r]) {",
      "            break;",
      "          }",
      "          l++;",
      "          r++;",
      "        }",
      "        if (l == n || s[l] != s[r]) same = false;",
      "      }",
      "      if (!same) rec_upper++;",
      "      rec_s[lms_map[sorted_lms[i]]] = rec_upper;",
      "    }",
      "",
      "    auto rec_sa = suffix_array_induced_sort(rec_s, rec_upper);",
      "",
      "    for (int i = 0; i < m; i++) {",
      "      sorted_lms[i] = lms[rec_sa[i]];",
      "    }",
      "    induce(sorted_lms);",
      "  }",
      "  return sa;",
      "}",
      "",
      "std::vector<int> suffix_array(const std::vector<int> &s, int upper) {",
      "  assert(0 <= upper);",
      "  for (int d : s) {",
      "    assert(0 <= d && d <= upper);",
      "  }",
      "  auto sa = suffarr::suffix_array_induced_sort(s, upper);",
      "  return sa;",
      "}",
      "",
      "template <class T>",
      "std::vector<int> suffix_array(const std::vector<T> &s) {",
      "  int n = int(s.size());",
      "  std::vector<int> idx(n);",
      "  iota(idx.begin(), idx.end(), 0);",
      "  sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });",
      "  std::vector<int> s2(n);",
      "  int now = 0;",
      "  for (int i = 0; i < n; i++) {",
      "    if (i && s[idx[i - 1]] != s[idx[i]]) now++;",
      "    s2[idx[i]] = now;",
      "  }",
      "  return suffarr::suffix_array_induced_sort(s2, now);",
      "}",
      "",
      "std::vector<int> suffix_array(const std::string &s) {",
      "  int n = int(s.size());",
      "  std::vector<int> s2(n);",
      "  for (int i = 0; i < n; i++) {",
      "    s2[i] = s[i];",
      "  }",
      "  return suffarr::suffix_array_induced_sort(s2, 255);",
      "}",
      "",
      "template <class T>",
      "std::vector<int> lcp_array(const std::vector<T> &s,",
      "                           const std::vector<int> &sa) {",
      "  int n = int(s.size());",
      "  assert(n >= 1);",
      "  std::vector<int> rnk(n);",
      "  for (int i = 0; i < n; i++) {",
      "    rnk[sa[i]] = i;",
      "  }",
      "  std::vector<int> lcp(n - 1);",
      "  int h = 0;",
      "  for (int i = 0; i < n; i++) {",
      "    if (h > 0) h--;",
      "    if (rnk[i] == 0) continue;",
      "    int j = sa[rnk[i] - 1];",
      "    for (; j + h < n && i + h < n; h++) {",
      "      if (s[j + h] != s[i + h]) break;",
      "    }",
      "    lcp[rnk[i] - 1] = h;",
      "  }",
      "  return lcp;",
      "}",
      "",
      "std::vector<int> lcp_array(const std::string &s, const std::vector<int> &sa) {",
      "  int n = int(s.size());",
      "  std::vector<int> s2(n);",
      "  for (int i = 0; i < n; i++) {",
      "    s2[i] = s[i];",
      "  }",
      "  return lcp_array(s2, sa);",
      "}",
      "",
      "long long count_distinct_substrings(const std::string& s) {",
      "  auto sa = suffix_array(s);",
      "  auto lcp = lcp_array(s, sa);",
      "  long long res = s.size() * (s.size() + 1) / 2;",
      "  res -= std::accumulate(lcp.begin(), lcp.end(), 0LL);",
      "  return res;",
      "}",
      "}  // namespace suffarr",
      "",
      "using suffarr::suffix_array;",
      "using suffarr::lcp_array;"
    ],
    "description": "suffarr"
  },
  "trie": {
    "prefix": "trie",
    "body": [
      "template <int kAlpha = 26, int kMin = 'a'>",
      "struct Trie {",
      "  struct Node {",
      "    int cnt = 0;",
      "    std::array<int, kAlpha> child{{}};",
      "  };",
      "",
      "  std::vector<Node> trie = {Node(), Node()};",
      "",
      "  template <typename Vec>",
      "  void insert(const Vec& s) {",
      "    int u = 1;",
      "    for (auto x : s) {",
      "      int ch = x - kmin;",
      "      if (trie[u].child[ch] == 0) {",
      "        trie[u].child[ch] = trie.size();",
      "        trie.emplace_back();",
      "      }",
      "      u = trie[u].child[ch];",
      "    }",
      "    trie[u].cnt++;",
      "  }",
      "",
      "  template <typename Vec>",
      "  int match_prefix(const Vec& s) {",
      "    int u = 1;",
      "    int res = 0;",
      "    for (auto x : s) {",
      "      int ch = x - kmin;",
      "      if (trie[u].child[ch] == 0) break;",
      "      res++;",
      "      u = trie[u].child[ch];",
      "    }",
      "    return res;",
      "  }",
      "",
      "  template <typename Vec>",
      "  int count_occurence(const Vec& s) {",
      "    int u = 1;",
      "    for (auto x : s) {",
      "      int ch = x - kmin;",
      "      if (trie[u].child[ch] == 0) return 0;",
      "      u = trie[u].child[ch];",
      "    }",
      "    return trie[u].cnt;",
      "  }",
      "};"
    ],
    "description": "trie"
  }
}