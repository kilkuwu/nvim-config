snippet fenw
	template <typename T = int64_t>
	struct FenwickTree {
		int n;
		std::vector<T> t;

		FenwickTree(int _n) : n(_n), t(n + 1, T()) {}

		void add(int p, T v) {
			for (; p <= n; p += p & -p) {
				t[p] += v;
			}
		}

		T get(int p) {
			T res = 0;
			for (; p > 0; p -= p & -p) {
				res += t[p];
			}
			return res;
		}
	};

snippet dsu 
	struct DSU {
		std::vector<int> e;

		DSU(int n) : e(n, -1) {}

		int find(int u) {
			return e[u] < 0 ? u : e[u] = find(e[u]);
		}
		
		bool merge(int u, int v) {
			u = find(u), v = find(v);
			if (u == v) return false;
			if (e[u] > e[v]) std::swap(u, v);
			e[u] += e[v];
			e[v] = u;
			return true;
		} 

		bool same(int u, int v) {
			return find(u) == find(v);
		}
		
		int size(int u) {
			return -e[find(u)];
		}
	};

snippet strhash
	template <int M = (int) 1e9 + 7, int P = 311>
	struct Hash {
		std::vector<int> hsh, ppw;

		Hash(const std::string& s, int p = P) : hsh(s.size() + 1, 0), ppw(s.size() + 1, 1) {
			for (int i = 0; i < (int) s.size(); i++) {
				hsh[i + 1] = ((int64_t) hsh[i] * p + s[i]) % M;
				ppw[i + 1] = (int64_t) ppw[i] * p % M;
			}
		}

		int get(int l, int r) {
			int res = ((int64_t) hsh[r] - (int64_t) hsh[l] * ppw[r - l]) % M;
			return res + (res < 0) * M;
		}
	};

snippet rng 
	std::mt19937_64 rng(std::chrono::high_resolution_clock::now().time_since_epoch().count());
	// std::mt19937_64 rng(0) // Fixed seed
	#define uid(a, b) std::uniform_int_distribution<long long>(a, b)(rng)


snippet stresstest
	#include <bits/stdc++.h>
	
	#define nl '\n'
	
	std::mt19937_64 rng(std::chrono::high_resolution_clock::now().time_since_epoch().count());
	#define uid(a, b) std::uniform_int_distribution<long long>(a, b)(rng)
	
	// file name
	#define TASK "B"
	
	void build_test_1() {
		std::ofstream inp("inp");
		// gen test here
		inp.close();
	}
	
	signed main() {
		int ntest = 10000;
		for (int test = 1; test <= ntest; test++) {
			std::cerr << "TEST " << test << std::endl;
	
			build_test_1();
	
			system(TASK ".exe < inp > wa");
			system(TASK "_brute.exe < inp > ac");

			if (system("fc ac wa") != 0) {
				system("type inp");
				return 0;
			}
		}
	} 

snippet mint
	template <int md>
	struct Modular {
		int v;

		constexpr Modular() : v(0) {}

		template <typename T>
		static inline int normalize(const T& x) {
			int res = -md <= x && x < md ? static_cast<int>(x) : static_cast<int>(x % md);
			return res + (res < 0) * md;
		}

		static constexpr int mod() {
			return md;
		}

		template <typename U>
		Modular(const U& x) : v(normalize(x)) {}

		const int& operator()() const { return v; }

		template <typename U>
		explicit operator U() const {
			return static_cast<U>(v);
		}

		using M = Modular;

		template <typename U>
		friend typename std::enable_if<std::is_integral<U>::value, M>::type power(M b, U e) {
			assert(e >= 0);
			M ans = 1;
			while (e) {
				if (e & 1) ans *= b;
				b *= b;
				e >>= 1;
			}
			return ans;
		}

		M inv() const {
			M res = power(*this, md - 2);
			return res;
		}

		M& operator+=(const M& y) { return v += y.v, v -= (v >= md) * md, *this; }
		M& operator-=(const M& y) { return v -= y.v, v += (v < 0) * md, *this; }
		M& operator*=(const M& y) { return v = (int64_t) v * y.v % md, *this; }
		M& operator/=(const M& y) { return *this *= y.inv(); }

		M& operator++() { return *this += M(1); }
		M& operator--() { return *this -= M(1); }

		M operator++(int) {
			M res(*this);
			return *this += M(1), res;
		}

		M operator--(int) {
			M res(*this);
			return *this -= M(1), res;
		}

		M operator-() const { return M(-v); }

		friend bool operator==(const M& x, const M& y) { return x.v == y.v; }
		friend bool operator<(const M& x, const M& y) { return x.v < y.v; }
		friend bool operator>(const M& x, const M& y) { return x.v > y.v; }
		friend bool operator<=(const M& x, const M& y) { return x.v <= y.v; }
		friend bool operator>=(const M& x, const M& y) { return x.v >= y.v; }
		friend bool operator!=(const M& x, const M& y) { return x.v != y.v; }

		template <typename Istream>
		friend Istream& operator>>(Istream& is, M& y) {
			int64_t x;
			is >> x;
			y.v = y.normalize(x);
			return is;
		}

		template <typename Ostream>
		friend Ostream& operator<<(Ostream& os, const M& y) {
			return os << y.v;
		}

		friend M operator+(const M& x, const M& y) { return M(x) += y; }
		friend M operator-(const M& x, const M& y) { return M(x) -= y; }
		friend M operator*(const M& x, const M& y) { return M(x) *= y; }
		friend M operator/(const M& x, const M& y) { return M(x) /= y; }
	};

	constexpr int md = 1e9 + 7;
	using Mint = Modular<md>;

snippet fio
	#define TASK "$0"
		if (fopen(TASK ".inp", "r")) {
			freopen(TASK ".inp", "r", stdin);
			freopen(TASK ".out", "w", stdout);
		}        

snippet cp
	#include <bits/stdc++.h>
	
	#define nl '\n'
	
	signed main() {
		std::ios::sync_with_stdio(false);
		std::cin.tie(nullptr);
		$0
	}      

snippet cf
	#include <bits/stdc++.h>
	
	#define nl '\n'
	
	void antisocial() {
		$0
	}
	
	signed main() {
		std::ios::sync_with_stdio(false);
		std::cin.tie(nullptr);
		int t = 1;
		std::cin >> t;
		while (t--) 
			antisocial(); 
	}      

snippet debug
	#ifdef LOCAL
	#include "template\debug.hpp"
	#else
	#define dbg(...) ;
	#define timer(...) ;
	#endif

snippet fcin
	static struct FastInput {
		static constexpr int BUF_SIZE = 1 << 20;
		char buf[BUF_SIZE];
		size_t chars_read = 0;
		size_t buf_pos = 0;
		FILE *in = stdin;
		char cur = 0;
	 
		inline char get_char() {
			if (buf_pos >= chars_read) {
				chars_read = fread(buf, 1, BUF_SIZE, in);
				buf_pos = 0;
				buf[0] = (chars_read == 0 ? -1 : buf[0]);
			}
			return cur = buf[buf_pos++];
		}
	 
		inline void tie(int) {}
	 
		inline explicit operator bool() {
			return cur != -1;
		}
	 
		inline static bool is_blank(char c) {
			return c <= ' ';
		}
	 
		inline bool skip_blanks() {
			while (is_blank(cur) && cur != -1) {
				get_char();
			}
			return cur != -1;
		}
	 
		inline FastInput& operator>>(char& c) {
			skip_blanks();
			c = cur;
			get_char();
			return *this;
		}
		
		inline FastInput& operator>>(std::string& s) {
			if (skip_blanks()) {
				s.clear();
				do {
					s += cur;
				} while (!is_blank(get_char()));
			}
			return *this;
		}
	 
		template <typename T>
		inline FastInput& read_integer(T& n) {
			// unsafe, doesn't check that characters are actually digits
			n = 0;
			if (skip_blanks()) {
				int sign = +1;
				if (cur == '-') {
					sign = -1;
					get_char();
				}
				do {
					n += n + (n << 3) + cur - '0';
				} while (!is_blank(get_char()));
				n *= sign;
			}
			return *this;
		}
	 
		template <typename T>
		inline typename std::enable_if<std::is_integral<T>::value, FastInput&>::type operator>>(T& n) {
			return read_integer(n);
		}
		
		template <typename T>
		inline typename std::enable_if<std::is_floating_point<T>::value, FastInput&>::type operator>>(T& n) {
			// not sure if really fast, for compatibility only
			n = 0;
			if (skip_blanks()) {
				std::string s;
				(*this) >> s;
				sscanf(s.c_str(), "%lf", &n);
			}
			return *this;
		}
	} fcin;

snippet perseg
		struct PersistentSegmentTree {
			struct Node {
				int l = 0, r = 0;
				int64_t v = 0;
			};
		
			int n;
			std::vector<Node> t = {Node()};
		
			PersistentSegmentTree(int _n) : n(_n) {}
		
			inline int copy(int k) { return t.emplace_back(t[k]), t.size() - 1; }
		
			int update(int k, int l, int r, int p, int v) {
				int id = copy(k);
				if (l == r) {
					t[id].v = v;
					return id;
				}
				int mid = (l + r) / 2;
				if (p <= mid) {
					int ll = update(t[id].l, l, mid, p, v);
					t[id].l = ll;
				} else {
					int rr = update(t[id].r, mid + 1, r, p, v);
					t[id].r = rr;
				}
				t[id].v = t[t[id].l].v + t[t[id].r].v;
				return id;
			}
		
			int64_t query(int k, int l, int r, int qL, int qR) {
				if (l > qR | r < qL) return 0;
				if (qL <= l && r <= qR) return t[k].v;
				int mid = (l + r) / 2;
				return query(t[k].l, l, mid, qL, qR) + query(t[k].r, mid + 1, r, qL, qR);
			}
		
			int64_t query(int k, int l, int r) { return query(k, 0, n - 1, l, r); }
		
			int update(int k, int p, int v) { return update(k, 0, n - 1, p, v); }
		};
	
snippet comb
		template <typename M>
		struct Comb {
			std::vector<M> _fact, _finv;
		
			Comb() : _fact(1, 1), _finv(1, 1) {}
		
			inline int size() const { return static_cast<int>(_fact.size()); }
		
			void _double_extend() {
				int old_size = size();
				int new_size = std::min(M::mod(), size() * 2);
		
				_fact.resize(new_size);
				_finv.resize(new_size);
		
				for (int i = old_size; i < new_size; i++) {
					_fact[i] = _fact[i - 1] * i;
				}
				
				_finv[new_size - 1] = _fact[new_size - 1].inv();
				for (int i = new_size - 2; i >= old_size; i--) {
					_finv[i] = _finv[i + 1] * (i + 1);
				}
			}
		
			/**
			 * Calculate ***n** choose **k***.
			*/
			M operator()(int n, int k) {
				if (k > n || k < 0) return M();
				while (size() <= n) {
					_double_extend();
				}
				return _fact[n] * _finv[n - k] * _finv[k];
			}
		
			M lucas(int64_t n, int64_t k) {
				if (k > n) return 0;
				if (n < md) return this->operator()(n, k);
				return lucas(n / md, k / md) * this->operator()(n % md, k % md);
			}
		};
		
		Comb<Mint> C;
	
snippet hld
	struct HLD {
		int n;
		std::vector<int> sz, pa, st, en, top, dep,  who;
		std::vector<std::vector<int>> adj;
		int ti;

		HLD() {}
		HLD(int _n) { init(_n); }
		void init(int _n) {
			this->n = _n;
			sz.resize(n);
			top.resize(n);
			dep.resize(n);
			pa.resize(n);
			st.resize(n);
			en.resize(n);
			who.resize(n);
			ti = 0;
			adj.assign(n, {});
		}
		void addEdge(int u, int v) {
			adj[u].push_back(v);
			adj[v].push_back(u);
		}
		void work(int root = 0) {
			top[root] = root;
			dep[root] = 0;
			pa[root] = -1;
			dfs1(root);
			dfs2(root);
		}
		void dfs1(int u) {
			if(pa[u] != -1) {
				adj[u].erase(find(adj[u].begin(), adj[u].end(), pa[u]));
			}

			sz[u] = 1;
			for(auto& v: adj[u]) {
				pa[v] = u;
				dep[v] = dep[u] + 1;
				dfs1(v);
				sz[u] += sz[v];
				if(sz[v] > sz[adj[u][0]]) {
					std::swap(v, adj[u][0]);
				}
			}
		}
		void dfs2(int u) {
			st[u] = ti++;
			who[st[u]] = u;
			for(auto v: adj[u]) {
				top[v] = v == adj[u][0] ? top[u] : v;
				dfs2(v);
			}
			en[u] = ti;
		}
		int lca(int u, int v) {
			while(top[u] != top[v]) {
				if(dep[top[u]] > dep[top[v]]) {
					u = pa[top[u]];
				} else {
					v = pa[top[v]];
				}
			}
			return dep[u] < dep[v] ? u : v;
		}

		int dist(int u, int v) { return dep[u] + dep[v] - 2 * dep[lca(u, v)]; }

		int jump(int u, int k) {
			if(dep[u] < k) {
				return -1;
			}

			int d = dep[u] - k;

			while(dep[top[u]] > d) {
				u = pa[top[u]];
			}

			return who[st[u] - dep[u] + d];
		}

		bool isAncestor(int u, int v) { return st[u] <= st[v] && st[v] < en[u]; }

		int rootedParent(int u, int v) {
			std::swap(u, v);
			if(u == v) {
				return u;
			}
			if(!isAncestor(u, v)) {
				return pa[u];
			}
			auto it = upper_bound(adj[u].begin(),
														adj[u].end(),
														v,
														[&](int x, int y) { return st[x] < st[y]; }) -
				1;
			return *it;
		}

		int rootedSize(int u, int v) {
			if(u == v) {
				return n;
			}
			if(!isAncestor(v, u)) {
				return sz[v];
			}
			return n - sz[rootedParent(u, v)];
		}

		int rootedLca(int a, int b, int c) {
			return lca(a, b) ^ lca(b, c) ^ lca(c, a);
		}
	};
	
snippet itseg
	template <typename T = int64_t, typename Op = std::plus<T>>
	struct FastSegmentTree {
		int n;
		std::vector<T> t;
		FastSegmentTree(int _n) : n(2 << std::__lg(_n)), t(2 * n, T()){};

		template <typename U>
		FastSegmentTree(const std::vector<U>& a) : n(2 << std::__lg(a.size())), t(2 * n, T()) {
			for (int i = n; i < n + (int) a.size(); i++) {
				t[i] = a[i - n];
			}
			for (int i = n - 1; i > 0; i--) {
				t[i] = Op()(t[i << 1], t[i << 1 | 1]);
			}
		}

		void update(int p, const T& v) {
			for (t[p += n] = v; p >>= 1;) {
				t[p] = Op()(t[p << 1], t[p << 1 | 1]);
			}
		}

		T query(int l, int r) {
			T resl = T(), resr = T();
			for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
				if (l & 1) resl = Op()(resl, t[l++]);
				if (r & 1) resr = Op()(t[--r], resr);
			}
			return Op()(resl, resr);
		}
	};

snippet lazyseg
	template <typename Info, typename Tag>
	struct LazySegmentTree {
		int n;
		std::vector<Info> info;
		std::vector<Tag> tag;
	
		LazySegmentTree() : n(0) {}
		LazySegmentTree(int _n) : n(_n), info(4 * n), tag(4 * n) {}
	
		inline void pull(int k) { info[k] = Info(info[k << 1], info[k << 1 | 1]); }
	
		inline void apply(int k, const Tag& t) {
			info[k].apply(t);
			tag[k].apply(t);
		}
	
		inline void push(int k) {
			if (!tag[k].has_update()) return;  // can be removed
			apply(k << 1, tag[k]);
			apply(k << 1 | 1, tag[k]);
			tag[k] = Tag();
		}
	
		template <typename T>
		void build(int k, int l, int r, const std::vector<T>& vals) {
			if (l == r) {
				info[k] = vals[l];
				tag[k] = Tag();
				return;
			}
			int mid = (l + r) >> 1;
			build(k << 1, l, mid, vals);
			build(k << 1 | 1, mid + 1, r, vals);
			pull(k);
		}
	
		template <typename T>
		void build(const std::vector<T>& vals) {
			assert((int) vals.size() == n);
			build(1, 0, n - 1, vals);
		}
	
		void modify(int k, int l, int r, int p, const Info& v) {
			if (l == r) {
				info[k] = v;
				return;
			}
			push(k);
			int mid = (l + r) >> 1;
			if (p <= mid) {
				modify(k << 1, l, mid, p, v);
			} else {
				modify(k << 1 | 1, mid + 1, r, p, v);
			}
			pull(k);
		}
	
		void modify(int p, const Info& v) { modify(1, 0, n - 1, p, v); }
	
		Info query(int k, int l, int r, int qL, int qR) {
			if (l > qR || r < qL) return Info();
			if (qL <= l && r <= qR) return info[k];
			push(k);
			int mid = (l + r) >> 1;
			return Info(query(k << 1, l, mid, qL, qR), query(k << 1 | 1, mid + 1, r, qL, qR));
		}
	
		Info query(int l, int r) { return query(1, 0, n - 1, l, r); }
	
		void update(int k, int l, int r, int qL, int qR, const Tag& t) {
			if (l > qR || r < qL) return;
			if (qL <= l && r <= qR) {
				apply(k, t);
				return;
			}
			push(k);
			int mid = (l + r) >> 1;
			update(k << 1, l, mid, qL, qR, t);
			update(k << 1 | 1, mid + 1, r, qL, qR, t);
			pull(k);
		}
	
		void update(int l, int r, const Tag& t) { update(1, 0, n - 1, l, r, t); }
	};
	
	struct Tag {
		int64_t a = 1, b = 0;
	
		void apply(const Tag& t) {
			a *= t.a;
			b = t.a * b + t.b;
		}
	
		inline bool has_update() { return !(a == 1 && b == 0); }
	};
	
	struct Info {
		int64_t value;
		int cnt;
	
		Info() : value(0), cnt(0) {}
		Info(int64_t v) : value(v), cnt(1) {}
		Info(const Info& a, const Info& b) : value(a.value + b.value), cnt(a.cnt + b.cnt) {}
	
		void apply(const Tag& t) { value = value * t.a + cnt * t.b; }
	};
	
	using LazyTree = LazySegmentTree<Info, Tag>;

snippet bigint
	namespace BigInteger {
	using cpx = std::complex<double>;
	const double PI = acos(-1);
	std::vector<cpx> roots = {{0, 0}, {1, 0}};
	
	void ensure_capacity(int min_capacity) {
		for (int len = roots.size(); len < min_capacity; len *= 2) {
			for (int i = len >> 1; i < len; i++) {
				roots.emplace_back(roots[i]);
				double angle = 2 * PI * (2 * i + 1 - len) / (len * 2);
				roots.emplace_back(cos(angle), sin(angle));
			}
		}
	}
	
	void fft(std::vector<cpx> &z, bool inverse) {
		int n = z.size();
		assert((n & (n - 1)) == 0);
		ensure_capacity(n);
		for (unsigned i = 1, j = 0; i < (unsigned) n; i++) {
			int bit = n >> 1;
			for (; j >= (unsigned) bit; bit >>= 1) j -= bit;
			j += bit;
			if (i < j) swap(z[i], z[j]);
		}
		for (int len = 1; len < n; len <<= 1) {
			for (int i = 0; i < n; i += len * 2) {
				for (int j = 0; j < len; j++) {
					cpx root = inverse ? conj(roots[j + len]) : roots[j + len];
					cpx u = z[i + j];
					cpx v = z[i + j + len] * root;
					z[i + j] = u + v;
					z[i + j + len] = u - v;
				}
			}
		}
		if (inverse)
			for (int i = 0; i < n; i++) z[i] /= n;
	}
	
	std::vector<int> multiply_bigint(const std::vector<int> &a, const std::vector<int> &b, int base) {
		int need = a.size() + b.size();
		int n = 1;
		while (n < need) n <<= 1;
		std::vector<cpx> p(n);
		for (size_t i = 0; i < (size_t) n; i++) {
			p[i] = cpx(i < a.size() ? a[i] : 0, i < b.size() ? b[i] : 0);
		}
		fft(p, false);
		// a[w[k]] = (p[w[k]] + conj(p[w[n-k]])) / 2
		// b[w[k]] = (p[w[k]] - conj(p[w[n-k]])) / (2*i)
		std::vector<cpx> ab(n);
		cpx r(0, -0.25);
		for (int i = 0; i < n; i++) {
			int j = (n - i) & (n - 1);
			ab[i] = (p[i] * p[i] - conj(p[j] * p[j])) * r;
		}
		fft(ab, true);
		std::vector<int> result(need);
		long long carry = 0;
		for (int i = 0; i < need; i++) {
			long long d = (long long) (ab[i].real() + 0.5) + carry;
			carry = d / base;
			result[i] = d % base;
		}
		return result;
	}
	
	std::vector<int> multiply_mod(const std::vector<int> &a, const std::vector<int> &b, int m) {
		int need = a.size() + b.size() - 1;
		int n = 1;
		while (n < need) n <<= 1;
		std::vector<cpx> A(n);
		for (size_t i = 0; i < a.size(); i++) {
			int x = (a[i] % m + m) % m;
			A[i] = cpx(x & ((1 << 15) - 1), x >> 15);
		}
		fft(A, false);
	
		std::vector<cpx> B(n);
		for (size_t i = 0; i < b.size(); i++) {
			int x = (b[i] % m + m) % m;
			B[i] = cpx(x & ((1 << 15) - 1), x >> 15);
		}
		fft(B, false);
	
		std::vector<cpx> fa(n);
		std::vector<cpx> fb(n);
		for (int i = 0, j = 0; i < n; i++, j = n - i) {
			cpx a1 = (A[i] + conj(A[j])) * cpx(0.5, 0);
			cpx a2 = (A[i] - conj(A[j])) * cpx(0, -0.5);
			cpx b1 = (B[i] + conj(B[j])) * cpx(0.5, 0);
			cpx b2 = (B[i] - conj(B[j])) * cpx(0, -0.5);
			fa[i] = a1 * b1 + a2 * b2 * cpx(0, 1);
			fb[i] = a1 * b2 + a2 * b1;
		}
	
		fft(fa, true);
		fft(fb, true);
		std::vector<int> res(need);
		for (int i = 0; i < need; i++) {
			long long aa = (long long) (fa[i].real() + 0.5);
			long long bb = (long long) (fb[i].real() + 0.5);
			long long cc = (long long) (fa[i].imag() + 0.5);
			res[i] = (aa % m + (bb % m << 15) + (cc % m << 30)) % m;
		}
		return res;
	}
	
	constexpr int digits(int base) noexcept { return base <= 1 ? 0 : 1 + digits(base / 10); }
	
	constexpr int base = 1000000000;
	constexpr int base_digits = digits(base);
	
	constexpr int fft_base = 10000;  // fft_base^2 * n / fft_base_digits <= 10^15 for double
	constexpr int fft_base_digits = digits(fft_base);
	
	struct BigInt {
		// value == 0 is represented by empty z
		std::vector<int> z;  // digits
	
		// sign == 1 <==> value >= 0
		// sign == -1 <==> value < 0
		int sign;
	
		BigInt(long long v = 0) { *this = v; }
	
		BigInt &operator=(long long v) {
			sign = v < 0 ? -1 : 1;
			v *= sign;
			z.clear();
			for (; v > 0; v = v / base) z.push_back((int) (v % base));
			return *this;
		}
	
		BigInt(const std::string &s) { read(s); }
	
		BigInt &operator+=(const BigInt &other) {
			if (sign == other.sign) {
				for (int i = 0, carry = 0; i < (int) other.z.size() || carry; ++i) {
					if (i == (int) z.size()) z.push_back(0);
					z[i] += carry + (i < (int) other.z.size() ? other.z[i] : 0);
					carry = z[i] >= base;
					if (carry) z[i] -= base;
				}
			} else if (other != 0 /* prevent infinite loop */) {
				*this -= -other;
			}
			return *this;
		}
	
		friend BigInt operator+(BigInt a, const BigInt &b) {
			a += b;
			return a;
		}
	
		BigInt &operator-=(const BigInt &other) {
			if (sign == other.sign) {
				if ((sign == 1 && *this >= other) || (sign == -1 && *this <= other)) {
					for (int i = 0, carry = 0; i < (int) other.z.size() || carry; ++i) {
						z[i] -= carry + (i < (int) other.z.size() ? other.z[i] : 0);
						carry = z[i] < 0;
						if (carry) z[i] += base;
					}
					trim();
				} else {
					*this = other - *this;
					this->sign = -this->sign;
				}
			} else {
				*this += -other;
			}
			return *this;
		}
	
		friend BigInt operator-(BigInt a, const BigInt &b) {
			a -= b;
			return a;
		}
	
		BigInt &operator*=(int v) {
			if (v < 0) sign = -sign, v = -v;
			for (int i = 0, carry = 0; i < (int) z.size() || carry; ++i) {
				if (i == (int) z.size()) z.push_back(0);
				long long cur = (long long) z[i] * v + carry;
				carry = (int) (cur / base);
				z[i] = (int) (cur % base);
			}
			trim();
			return *this;
		}
	
		BigInt operator*(int v) const { return BigInt(*this) *= v; }
	
		friend std::pair<BigInt, BigInt> divmod(const BigInt &a1, const BigInt &b1) {
			int norm = base / (b1.z.back() + 1);
			BigInt a = a1.abs() * norm;
			BigInt b = b1.abs() * norm;
			BigInt q, r;
			q.z.resize(a.z.size());
	
			for (int i = (int) a.z.size() - 1; i >= 0; i--) {
				r *= base;
				r += a.z[i];
				int s1 = b.z.size() < r.z.size() ? r.z[b.z.size()] : 0;
				int s2 = b.z.size() - 1 < r.z.size() ? r.z[b.z.size() - 1] : 0;
				int d = (int) (((long long) s1 * base + s2) / b.z.back());
				r -= b * d;
				while (r < 0) r += b, --d;
				q.z[i] = d;
			}
	
			q.sign = a1.sign * b1.sign;
			r.sign = a1.sign;
			q.trim();
			r.trim();
			return {q, r / norm};
		}
	
		friend BigInt sqrt(const BigInt &a1) {
			BigInt a = a1;
			while (a.z.empty() || a.z.size() % 2 == 1) a.z.push_back(0);
	
			int n = a.z.size();
	
			int firstDigit = (int) ::sqrt((double) a.z[n - 1] * base + a.z[n - 2]);
			int norm = base / (firstDigit + 1);
			a *= norm;
			a *= norm;
			while (a.z.empty() || a.z.size() % 2 == 1) a.z.push_back(0);
	
			BigInt r = (long long) a.z[n - 1] * base + a.z[n - 2];
			firstDigit = (int) ::sqrt((double) a.z[n - 1] * base + a.z[n - 2]);
			int q = firstDigit;
			BigInt res;
	
			for (int j = n / 2 - 1; j >= 0; j--) {
				for (;; --q) {
					BigInt r1 = (r - (res * 2 * base + q) * q) * base * base +
											(j > 0 ? (long long) a.z[2 * j - 1] * base + a.z[2 * j - 2] : 0);
					if (r1 >= 0) {
						r = r1;
						break;
					}
				}
				res *= base;
				res += q;
	
				if (j > 0) {
					int d1 = res.z.size() + 2 < r.z.size() ? r.z[res.z.size() + 2] : 0;
					int d2 = res.z.size() + 1 < r.z.size() ? r.z[res.z.size() + 1] : 0;
					int d3 = res.z.size() < r.z.size() ? r.z[res.z.size()] : 0;
					q = (int) (((long long) d1 * base * base + (long long) d2 * base + d3) / (firstDigit * 2));
				}
			}
	
			res.trim();
			return res / norm;
		}
	
		BigInt operator/(const BigInt &v) const { return divmod(*this, v).first; }
	
		BigInt operator%(const BigInt &v) const { return divmod(*this, v).second; }
	
		BigInt &operator/=(int v) {
			if (v < 0) sign = -sign, v = -v;
			for (int i = (int) z.size() - 1, rem = 0; i >= 0; --i) {
				long long cur = z[i] + rem * (long long) base;
				z[i] = (int) (cur / v);
				rem = (int) (cur % v);
			}
			trim();
			return *this;
		}
	
		BigInt operator/(int v) const { return BigInt(*this) /= v; }
	
		int operator%(int v) const {
			if (v < 0) v = -v;
			int m = 0;
			for (int i = (int) z.size() - 1; i >= 0; --i) m = (int) ((z[i] + m * (long long) base) % v);
			return m * sign;
		}
	
		BigInt &operator*=(const BigInt &v) {
			*this = *this * v;
			return *this;
		}
	
		BigInt &operator/=(const BigInt &v) {
			*this = *this / v;
			return *this;
		}
	
		BigInt &operator%=(const BigInt &v) {
			*this = *this % v;
			return *this;
		}
	
		bool operator<(const BigInt &v) const {
			if (sign != v.sign) return sign < v.sign;
			if (z.size() != v.z.size()) return z.size() * sign < v.z.size() * v.sign;
			for (int i = (int) z.size() - 1; i >= 0; i--)
				if (z[i] != v.z[i]) return z[i] * sign < v.z[i] * sign;
			return false;
		}
	
		bool operator>(const BigInt &v) const { return v < *this; }
	
		bool operator<=(const BigInt &v) const { return !(v < *this); }
	
		bool operator>=(const BigInt &v) const { return !(*this < v); }
	
		bool operator==(const BigInt &v) const { return sign == v.sign && z == v.z; }
	
		bool operator!=(const BigInt &v) const { return !(*this == v); }
	
		void trim() {
			while (!z.empty() && z.back() == 0) z.pop_back();
			if (z.empty()) sign = 1;
		}
	
		bool isZero() const { return z.empty(); }
	
		friend BigInt operator-(BigInt v) {
			if (!v.z.empty()) v.sign = -v.sign;
			return v;
		}
	
		BigInt abs() const { return sign == 1 ? *this : -*this; }
	
		long long longValue() const {
			long long res = 0;
			for (int i = (int) z.size() - 1; i >= 0; i--) res = res * base + z[i];
			return res * sign;
		}
	
		friend BigInt gcd(const BigInt &a, const BigInt &b) { return b.isZero() ? a : gcd(b, a % b); }
	
		friend BigInt lcm(const BigInt &a, const BigInt &b) { return a / gcd(a, b) * b; }
	
		void read(const std::string &s) {
			sign = 1;
			z.clear();
			int pos = 0;
			while (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {
				if (s[pos] == '-') sign = -sign;
				++pos;
			}
			for (int i = (int) s.size() - 1; i >= pos; i -= base_digits) {
				int x = 0;
				for (int j = std::max(pos, i - base_digits + 1); j <= i; j++) x = x * 10 + s[j] - '0';
				z.push_back(x);
			}
			trim();
		}
	
		friend std::istream &operator>>(std::istream &stream, BigInt &v) {
			std::string s;
			stream >> s;
			v.read(s);
			return stream;
		}
	
		friend std::ostream &operator<<(std::ostream &stream, const BigInt &v) {
			if (v.sign == -1) stream << '-';
			stream << (v.z.empty() ? 0 : v.z.back());
			for (int i = (int) v.z.size() - 2; i >= 0; --i) stream << std::setw(base_digits) << std::setfill('0') << v.z[i];
			return stream;
		}
	
		static std::vector<int> convert_base(const std::vector<int> &a, int old_digits, int new_digits) {
			std::vector<long long> p(std::max(old_digits, new_digits) + 1);
			p[0] = 1;
			for (int i = 1; i < (int) p.size(); i++) p[i] = p[i - 1] * 10;
			std::vector<int> res;
			long long cur = 0;
			int cur_digits = 0;
			for (int v : a) {
				cur += v * p[cur_digits];
				cur_digits += old_digits;
				while (cur_digits >= new_digits) {
					res.push_back(int(cur % p[new_digits]));
					cur /= p[new_digits];
					cur_digits -= new_digits;
				}
			}
			res.push_back((int) cur);
			while (!res.empty() && res.back() == 0) res.pop_back();
			return res;
		}
	
		BigInt operator*(const BigInt &v) const {
			if (std::min(z.size(), v.z.size()) < 150) return mul_simple(v);
			BigInt res;
			res.sign = sign * v.sign;
			res.z = multiply_bigint(convert_base(z, base_digits, fft_base_digits),
															convert_base(v.z, base_digits, fft_base_digits), fft_base);
			res.z = convert_base(res.z, fft_base_digits, base_digits);
			res.trim();
			return res;
		}
	
		BigInt mul_simple(const BigInt &v) const {
			BigInt res;
			res.sign = sign * v.sign;
			res.z.resize(z.size() + v.z.size());
			for (int i = 0; i < (int) z.size(); ++i)
				if (z[i])
					for (int j = 0, carry = 0; j < (int) v.z.size() || carry; ++j) {
						long long cur = res.z[i + j] + (long long) z[i] * (j < (int) v.z.size() ? v.z[j] : 0) + carry;
						carry = (int) (cur / base);
						res.z[i + j] = (int) (cur % base);
					}
			res.trim();
			return res;
		}
	};
	}  // namespace BigInteger
	
	using BigInteger::BigInt;
